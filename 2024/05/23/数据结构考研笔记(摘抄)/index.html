<!-- build time:Tue Oct 08 2024 10:14:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="REM" href="https://loveremu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="REM" href="https://loveremu.github.io/atom.xml"><link rel="alternate" type="application/json" title="REM" href="https://loveremu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/"><title>数据结构考研笔记(摘抄) - 408 | REMU's blog = REM = レムは天下一品だ</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构考研笔记(摘抄)</h1><div class="meta"><span class="item" title="创建时间：2024-05-23 22:46:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-05-23T22:46:13+08:00">2024-05-23</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">REMU's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://LOVEREMU.github.io/images/7-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/3-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/1c96818ab5347906b12d081223b0bf5d.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/5-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/9-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/bfaa5f3a4fb5c982eaeead045be3c4b7.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/408/" itemprop="item" rel="index" title="分类于 408"><span itemprop="name">408</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="REMU"><meta itemprop="description" content="レムは天下一品だ, LOVEREMU blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="REM"></span><div class="body md" itemprop="articleBody"><h1 id="数据结构考研"><a class="anchor" href="#数据结构考研">#</a> 数据结构考研</h1><h2 id="1绪论"><a class="anchor" href="#1绪论">#</a> 1. 绪论</h2><h3 id="1-数据结构的基本概念"><a class="anchor" href="#1-数据结构的基本概念">#</a> 1. 数据结构的基本概念</h3><ul><li>可以用<mark>抽象数据类型</mark>定义一个完整的数据结构</li><li>与数据存储结构无关的术语是<mark>栈</mark>， <mark>循环队列</mark>是用顺序表表示的队列，是一种数据结构</li><li><mark>数据的逻辑结构独立于其存储结构</mark></li><li>在存储数据时，不仅要存储数据元素的值，还要存储<mark>数据元素之间的关系</mark></li><li>链式存储设计时，节点内的存储单元地址<mark>一定连续</mark></li></ul><p>不同节点的存储单元地址可以不连续，节点内的存储单元地址必须连续</p><h3 id="2-算法和算法评价"><a class="anchor" href="#2-算法和算法评价">#</a> 2. 算法和算法评价</h3><ul><li>一个算法应该是<mark>问题求解的步骤</mark></li><li>算法原地工作是指<mark>算法所需的辅助空间是常量</mark></li></ul><h2 id="2-线性表"><a class="anchor" href="#2-线性表">#</a> 2. 线性表</h2><h3 id="1-线性表的顺序表示"><a class="anchor" href="#1-线性表的顺序表示">#</a> 1. 线性表的顺序表示</h3><ul><li><mark>存储密度大</mark>是顺序存储结构的优点</li><li>线性表的顺序存储结构是一种<mark>随机存取的存储结构</mark></li><li><mark>线性表的序号是从一开始</mark></li></ul><h3 id="2-线性表的链式表示"><a class="anchor" href="#2-线性表的链式表示">#</a> 2. 线性表的链式表示</h3><ul><li><mark>链式存储结构比顺序存储结构能更方便的表示各种逻辑结构</mark></li><li><mark>静态链表需要分配较大的连续空间，插入和删除不需要移动元素</mark></li><li>单链表中，增加一个头结点的目的是方便运算的实现</li><li><mark>单链表中，删除最后一个元素与链表长度有关，其他操作均无关</mark></li><li><mark>在尾结点插入和删除数据，带头结点的双循环链表最节省时间</mark></li></ul><h2 id="3-栈队列和数组"><a class="anchor" href="#3-栈队列和数组">#</a> 3. 栈，队列和数组</h2><h3 id="1-栈"><a class="anchor" href="#1-栈">#</a> 1. 栈</h3><ul><li>栈和队列具有相同的<mark>逻辑结构</mark></li><li>向一个栈顶指针为 top 的链栈（不带头结点）中插入一个 X 节点，则执行<mark> x-&gt;next=top;top=x</mark></li><li>采用共享栈的好处是<mark>节省存储空间，降低发生上溢的可能</mark></li></ul><h3 id="2-栈和队列的应用"><a class="anchor" href="#2-栈和队列的应用">#</a> 2. 栈和队列的应用</h3><ul><li>栈在<mark>括号应用，表达式求值，递归，进制转换，迷宫求解</mark>等中有应用</li><li>队列在<mark>层序遍历，bfs，缓冲区，页面替换算法等</mark>中有应用</li></ul><h2 id="4-串"><a class="anchor" href="#4-串">#</a> 4. 串</h2><ul><li><mark>简单的模式匹配算法时间复杂度为 O (mn)，KMP 算法的时间复杂度为 O (m+n)</mark></li><li>KMP 算法求 next 数组（重点），视频 P36</li></ul><h2 id="5-树与二叉树"><a class="anchor" href="#5-树与二叉树">#</a> 5. 树与二叉树</h2><h3 id="1-树的基本概念"><a class="anchor" href="#1-树的基本概念">#</a> 1. 树的基本概念</h3><ul><li>树的路径长度是<mark>从树根到每个节点的路径长度的总和</mark></li><li>树中所有节点的度数之和 = 树的所有分支 = 树的节点数目 - 1</li><li>设树中度为 i 的节点数为 ni</li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点数 = 各个度的节点数之和 = 1 + 分支数 </span><br><span class="line">n=n0+n1+n2+n3 = 1+n1+2n2+3n3</span><br></pre></td></tr></table></figure><p></p><h3 id="2-二叉树的概念"><a class="anchor" href="#2-二叉树的概念">#</a> 2. 二叉树的概念</h3><ul><li>非空二叉树上的叶子节点数等于度为 2 的节点数加 1，即 <mark>n0= n2+1</mark></li><li>非空二叉树第 k 层上至多有 <mark>2^(k-1)</mark> 个节点</li><li>高度为 h 的二叉树至多有 <mark>2^h -1</mark> 个节点</li><li>在含有 n 个节点的二叉链表中，含有 <mark>n+1</mark> 个空链域</li></ul><h3 id="3-二叉树的遍历与线索二叉树"><a class="anchor" href="#3-二叉树的遍历与线索二叉树">#</a> 3. 二叉树的遍历与线索二叉树</h3><ul><li>在二叉树中，m 是 n 的祖先，使用<mark>后序遍历</mark>可以找到 m 到 n 的路径</li><li>在二叉树的前序，中序，后序遍历中，所有叶子节点的先后顺序<mark>完全相同</mark></li><li>二叉树的先序和后序完全相反，二叉树一定满足<mark>只有一个叶子节点</mark></li><li><mark>唯一不能确定一颗二叉树的是 先序遍历和后序遍历</mark></li><li>线索二叉树是一种<mark>物理结构</mark>，<mark>tag 为 0 时指向孩子节点，为 1 时指向线索节点</mark></li><li><mark>二叉树在线索化后，仍不能有效求解后序线索二叉树求后序后继</mark></li><li><mark>后序线索树</mark>遍历仍需要 栈 的支持</li></ul><h3 id="3-树森林"><a class="anchor" href="#3-树森林">#</a> 3. 树，森林</h3><ul><li><p>将树转变成二叉树：<mark>左孩子右兄弟</mark></p></li><li><p>将森林 F 转换为对应的二叉树 T，F 中叶节点的个数等于 <mark>T 中左孩子指针为空的节点个数</mark></p></li></ul><p>在一颗二叉树中，如果某个节点的左指针为 NULL，就说明这个节点在原来的森林中没有孩子，是叶子节点</p><h3 id="4-树与二叉树的应用"><a class="anchor" href="#4-树与二叉树的应用">#</a> 4. 树与二叉树的应用</h3><ul><li>若没有编码是另一个编码的前缀，则称这样的编码为<mark>前缀编码</mark></li><li><mark>在哈夫曼树中只有叶子结点才能作为字符编码</mark></li><li>对应一组权值构造出的哈夫曼树不是惟一的</li><li>哈夫曼树的度只有 0 和 2，没有 1</li><li>并查集的结构是一种 <mark>双亲表示法存储的树</mark></li><li><mark>并查集查找操作的时间复杂度为 O (n)</mark></li></ul><h2 id="6图"><a class="anchor" href="#6图">#</a> 6. 图</h2><h3 id="1-图的基本概念"><a class="anchor" href="#1-图的基本概念">#</a> 1. 图的基本概念</h3><ul><li>图中有关路径的定义：<mark>由顶点和相邻顶点序偶构成的边所形成的序列</mark></li><li><mark>无向图的全部顶点的度的和等于边数的两倍</mark></li><li><mark>强连通有向图至少有 n 条边</mark>（构成环）</li></ul><h3 id="2-图的存储及基本操作"><a class="anchor" href="#2-图的存储及基本操作">#</a> 2. 图的存储及基本操作</h3><ul><li>无向图的度为<mark>邻接矩阵中第 i 行或第 i 列非零元素之和</mark></li><li>一个图的邻接矩阵表示唯一，邻接表表示不唯一</li><li>在有向图的邻接表存储结构中，顶点 v 在边表中出现的次数为 <mark>顶点 v 的入度</mark></li></ul><p>解释：这里的边表不包含顶点表（即出度）</p><ul><li>假设有 n 个顶点，e 条边的有向表用邻接表表示，则删除与某个顶点 v 相关的所有边的时间复杂度为<mark> O (n+e)</mark></li><li><mark>十字链表是有向图的链式存储结构</mark></li><li><mark>邻接多重表是无向图的链式存储结构</mark></li></ul><h3 id="3-图的遍历"><a class="anchor" href="#3-图的遍历">#</a> 3. 图的遍历</h3><ul><li><p>当各边的权值相等时，广度优先算法可以解决<mark>单源最短路径问题</mark></p></li><li><p><mark>图的广搜使用队列，深搜使用栈</mark></p></li><li><p><mark>图的深搜相当于树的 先序遍历</mark></p></li><li><p>判断有向图中是否存在回路，除了利用拓扑排序外，还可以利用 <mark>深度优先遍历，求关键路径</mark>（求最短路径不行）</p></li><li><p>使用 DFS 算法递归的遍历一个有环无向图，在退出递归时输出相应顶点，这样得到的顶点序列是<mark>逆拓扑有序</mark></p></li></ul><h3 id="4-图的应用"><a class="anchor" href="#4-图的应用">#</a> 4. 图的应用</h3><ul><li><mark>只要无向连通图中没有权值相同的边，则其最小生成树唯一</mark>、</li><li><mark>最短路径一定是简单路径</mark></li><li>若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图<mark>含有顶点数大于 1 的强连通分量</mark></li><li>若一个有向图具有<mark>有序</mark>的拓扑排序序列，则它的邻接矩阵必定为 <mark>三角</mark></li><li>最小生成树代价唯一（形状可能不唯一）</li></ul><h2 id="7查找"><a class="anchor" href="#7查找">#</a> 7. 查找</h2><h3 id="1-顺序查找和折半查找"><a class="anchor" href="#1-顺序查找和折半查找">#</a> 1. 顺序查找和折半查找</h3><ul><li>折半查找过程所对应的判定树是一棵<mark>平衡二叉树</mark></li><li>折半查找和二叉排序树的时间性能<mark>有时不相同</mark></li></ul><p>二叉排序树的查找性能和数据的输入顺序有关，最坏情况形成单支树，查找长度为 O (n)</p><ul><li>对表长为 n 的有序表进行折半查找，判定树的高度为 <mark>log2 (n+1) 向上取整</mark></li></ul><h3 id="2-树形查找"><a class="anchor" href="#2-树形查找">#</a> 2. 树形查找</h3><ul><li>平衡二叉树（AVL）左子树与右子树的高度差称为平衡因子（-1,0,1）</li><li><mark>节点数最少的平衡二叉树节点数的递推公式（重要）</mark></li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1=1  n2=2</span><br><span class="line">n3=n1+n2+1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><ul><li>AVL 中所有非叶子节点的平衡因子均为 1，说明它的叶子节点数最少</li><li>平衡树的查询效率一般优于红黑树</li><li>一棵含有 n 个节点的红黑树的高度至多为 <mark>2log(n+1)</mark></li><li><mark>红黑树任意节点的左右子树的高度之差不超过两倍</mark></li><li><mark>如果红黑树的所有节点都是黑色的，那么它一定是一棵满二叉树</mark></li></ul><h3 id="3-b树b树"><a class="anchor" href="#3-b树b树">#</a> 3. B 树，B + 树</h3><ul><li>B + 树不同于 B 树的特点之一是<mark>能支持顺序查找</mark></li><li>B 树和 B + 树都可以用于文件索引结构</li><li>B + 树更加适用于实际应用中的<mark>操作系统中的文件索引和数据库索引</mark></li></ul><h3 id="4-散列表"><a class="anchor" href="#4-散列表">#</a> 4. 散列表</h3><ul><li><mark>散列表查找成功的平均查找长度与散列因子有关，与表长无关</mark></li><li>若在散列表中删除一个元素，不能简单地将该元素删除（在删除地方做删除标记）</li><li><mark>采用再散列法处理冲突时不易产生聚集</mark></li><li><mark>使用链地址法不会引起聚集现象</mark></li></ul><h2 id="8-排序"><a class="anchor" href="#8-排序">#</a> 8. 排序</h2><h3 id="1-排序的基本概念"><a class="anchor" href="#1-排序的基本概念">#</a> 1. 排序的基本概念</h3><ul><li><mark>排序算法的稳定性是指经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变</mark></li><li>拓扑排序不属于内部排序方法</li><li><mark>使用链表也可以进行排序，只不过有些排序算法不在适用</mark></li><li><mark>对同一线性表使用不同的排序方法进行排序，得到的排序结果可能不同</mark></li><li>对任意 n 个关键字排序的比较次数至少为 <mark>log2 (n!) 向上取整</mark></li></ul><h3 id="2-插入排序"><a class="anchor" href="#2-插入排序">#</a> 2. 插入排序</h3><ul><li><p>插入排序：直接插入排序，折半插入排序，希尔排序</p></li><li><p>对 n 个元素的顺序表进行直接插入排序算法，<mark>最坏情况下所需的比较次数是 n (n-1)/2 , 最好情况下是（n-1）</mark></p></li><li><p>与直接插入排序相比，折半插入排序减少了比较元素的次数，元素的移动次数并未改变</p></li></ul><h3 id="3交换排序"><a class="anchor" href="#3交换排序">#</a> 3. 交换排序</h3><ul><li>交换排序：冒泡排序，快速排序</li><li><mark>快速排序：当每次枢轴都把表等分位长度相近的两个子表时，速度是最快的；当表本身已经有序或者逆序时，速度最慢</mark></li><li>递归次数与每次划分后得到的分区的处理顺序无关</li><li><mark>快速排序的阶段性特点是：第 i 趟完成时，会有 i 个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，右边的数都比它大</mark></li></ul><h3 id="4-选择排序"><a class="anchor" href="#4-选择排序">#</a> 4. 选择排序</h3><ul><li>选择排序：简单选择排序，堆排序</li><li><mark>简单选择排序的比较次数和移动次数分别为 O (n^2)，O (n)</mark></li><li><mark>通常，取一大堆数据中的 K 个最大（最小）元素时，都优先采用堆排序</mark></li><li>向具有 n 个元素的堆中插入一个元素的时间复杂度为 O (logn), 删除一个元素的时间复杂度为 O (logn)</li><li>构建 n 个记录的初始堆，时间复杂度为 O (n) , 进行堆排序，最坏情况下，时间复杂度为 O (nlogn)</li></ul><h3 id="5-归并排序和基数排序"><a class="anchor" href="#5-归并排序和基数排序">#</a> 5. 归并排序和基数排序</h3><ul><li>基数排序不需要进行关键字的比较</li><li>平均情况下空间复杂度为 O (n) 的是<mark>归并排序</mark>，最坏情况下空间复杂度为 O (n) 的是 <mark>归并排序，快速排序</mark></li><li>对 10TB 的数据文件进行排序，应使用的方法是<mark>归并排序</mark></li></ul><h3 id="6各个排序算法比较"><a class="anchor" href="#6各个排序算法比较">#</a> 6. 各个排序算法比较</h3><table><thead><tr><th>排序算法名称</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>适用性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>顺序存储和链式存储</td></tr><tr><td>折半插入排序</td><td>O(n^2)</td><td></td><td>稳定</td><td>顺序存储</td></tr><tr><td>希尔排序</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>顺序存储</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>顺序存储</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td><td>顺序存储</td></tr><tr><td>简单选择排序</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td><td></td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td><td></td></tr><tr><td>基数排序</td><td>O(d（n+r）)</td><td>O(r)</td><td>稳定</td><td></td></tr></tbody></table><ul><li>排序趟数与序列初始状态无关的排序算法是 <mark>直接插入，简单选择，基数排序，归并排序</mark></li><li>每趟排序结束后都至少能够确定一个元素最终位置的方法是<mark>简单选择，冒泡排序，快速，堆排序</mark></li><li>元素的移动次数与初始排列次序无关的是<mark>基数排序</mark></li></ul><h3 id="7-外部排序"><a class="anchor" href="#7-外部排序">#</a> 7. 外部排序</h3><ul><li>在做 m 路平衡归并排序的过程中，为实现<mark>输入 / 内部归并 / 输出的并行处理</mark>，需要设置 <mark>2m 个输入缓冲区，2 个输出缓冲区</mark></li><li>如何判定添加虚段的数目？</li></ul><p>设度为 0 的节点有 N0 个，度为 k 的节点有 Nk 个，则对严格的 k 叉树有 N0 = (k-1) Nk+1 ，由此得 <mark>NK = （N0-1）/(k-1)</mark> (Nk 必须为整数)</p><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-05-23 20:18:36" itemprop="dateModified" datetime="2024-05-23T20:18:36+08:00">2024-05-23</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="REMU 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="REMU 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="REMU 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>REMU <i class="ic i-at"><em>@</em></i>REM</li><li class="link"><strong>本文链接：</strong> <a href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="数据结构考研笔记(摘抄)">https://loveremu.github.io/2024/05/23/数据结构考研笔记(摘抄)/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;7-min.jpg" title="数据结构(摘抄)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 408</span><h3>数据结构(摘抄)</h3></a></div><div class="item right"><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;bfaa5f3a4fb5c982eaeead045be3c4b7.jpg" title="操作系统考研笔记(摘抄)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 408</span><h3>操作系统考研笔记(摘抄)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94"><span class="toc-number">1.</span> <span class="toc-text">数据结构考研</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1. 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 数据结构的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 算法和算法评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2. 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 线性表的顺序表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 线性表的链式表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">3. 栈，队列和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 栈和队列的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">4. 串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">5. 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 二叉树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 二叉树的遍历与线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%91%E6%A3%AE%E6%9E%97"><span class="toc-number">1.5.4.</span> <span class="toc-text">3. 树，森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">4. 树与二叉树的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">6. 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 图的存储及基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 图的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.</span> <span class="toc-text">7. 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 顺序查找和折半查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 树形查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-b%E6%A0%91b%E6%A0%91"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. B 树，B + 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 散列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">8. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 排序的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 交换排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. 归并排序和基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%90%84%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.6.</span> <span class="toc-text">6. 各个排序算法比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.7.</span> <span class="toc-text">7. 外部排序</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="操作系统考研笔记(摘抄)">操作系统考研笔记(摘抄)</a></li><li class="active"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="数据结构考研笔记(摘抄)">数据结构考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" rel="bookmark" title="数据结构(摘抄)">数据结构(摘抄)</a></li><li><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%91%98%E6%8A%84)/" rel="bookmark" title="操作系统(摘抄)">操作系统(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机组成原理考研笔记(摘抄)">计算机组成原理考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机组成原理(摘抄)">计算机组成原理(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%BD%91%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机网络考研笔记(摘抄)">计算机网络考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机网络(摘抄)">计算机网络(摘抄)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="REMU" data-src="/images/avatar.jpg"><p class="name" itemprop="name">REMU</p><div class="description" itemprop="description">LOVEREMU blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" title="数据结构(摘抄)">数据结构(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="分类于 语言基础">语言基础</a></div><span><a href="/2023/07/28/JAVA-PLUS/" title="JAVA-PLUS">JAVA-PLUS</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/05/31/phigros%E7%AC%AC%E4%BA%8C%E9%A6%96%E9%AD%94%E7%8E%8B%E6%9B%B2/" title="phigros第二首魔王曲">phigros第二首魔王曲</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/Springboot/" title="Springboot基础">Springboot基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="数据结构考研笔记(摘抄)">数据结构考研笔记(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/Linux%E5%9F%BA%E7%A1%80/" title="Linux基础">Linux基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a></div><span><a href="/2023/07/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="搜索与图论">搜索与图论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/06/05/phigros%E7%AC%AC%E4%BA%94%E9%A6%96%E9%AD%94%E7%8E%8B%E6%9B%B2/" title="phigros第四首魔王曲(终章)">phigros第四首魔王曲(终章)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%91%98%E6%8A%84)/" title="操作系统(摘抄)">操作系统(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2024/03/28/xxxHOLIC/" title="四月一日灵异事件薄">四月一日灵异事件薄</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">REMU @ REMU's blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/05/23/数据结构考研笔记(摘抄)/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->