<!-- build time:Tue Aug 13 2024 08:56:56 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="REM" href="https://loveremu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="REM" href="https://loveremu.github.io/atom.xml"><link rel="alternate" type="application/json" title="REM" href="https://loveremu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/"><title>数据结构(摘抄) - 408 | REMU's blog = REM = レムは天下一品だ</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构(摘抄)</h1><div class="meta"><span class="item" title="创建时间：2024-05-23 22:46:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-05-23T22:46:13+08:00">2024-05-23</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">REMU's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://LOVEREMU.github.io/images/6-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/3-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/1-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/5-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/7-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/04034f662a6365690992b3b18702e4bf.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/408/" itemprop="item" rel="index" title="分类于 408"><span itemprop="name">408</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="REMU"><meta itemprop="description" content="レムは天下一品だ, LOVEREMU blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="REM"></span><div class="body md" itemprop="articleBody"><h1 id="数据结构"><a class="anchor" href="#数据结构">#</a> 数据结构</h1><blockquote><p>数据结构的笔记不是看王道视频整理的，而是根据南京邮电大学的数据结构课程整理的。希望各位同学不要混淆，当然，考 408 的同学也可以参考。</p></blockquote><h2 id="1-绪论"><a class="anchor" href="#1-绪论">#</a> 1 绪论</h2><h3 id="11算法的基本概念"><a class="anchor" href="#11算法的基本概念">#</a> 1.1 算法的基本概念</h3><ul><li>程序与算法的区别和联系</li></ul><p>联系：程序是计算机指令的有序集合，是算法用某种程序设计语言的表述，是算法在计算机上的具体实现。<br>区别：在语言描述上不同，程序必须是用规定的程序设计语言来写，而算法的描述形式包括自然语言、伪代码、流程图和程序语言等；算法所描述的步骤 — 定是有限的，而程序可以无限地执行下去，比如一个死循环可以称为程序，但不能称为算法。</p><h3 id="12数据结构的基本概念"><a class="anchor" href="#12数据结构的基本概念">#</a> 1.2 数据结构的基本概念</h3><p>数据结构是由某一数据对象及该对象中所有数据元素之间的关系组成的。数据结构包括数据的逻辑结构，存储结构及数据的运算三方面的内容。</p><h3 id="13数据抽象和抽象数据类型"><a class="anchor" href="#13数据抽象和抽象数据类型">#</a> 1.3 数据抽象和抽象数据类型</h3><p>抽象数据类型（ADT）是一个数据模型以及在其上定义的运算集合。最主要的特征是数据封装和信息隐蔽。</p><h3 id="14描述数据结构和算法"><a class="anchor" href="#14描述数据结构和算法">#</a> 1.4 描述数据结构和算法</h3><ul><li>算法的五个特征</li></ul><ol><li>输入：0 个及以上</li><li>输出：1 个及以上</li><li>可行性</li><li>确定性</li><li>有穷性</li></ol><h3 id="15算法分析的基本方法"><a class="anchor" href="#15算法分析的基本方法">#</a> 1.5 算法分析的基本方法</h3><p>算法的时间复杂度一般是指程序运行从开始到结束所需的时间。</p><p>算法执行时间需通过依据该算法编制的程序在计算机上运行所消耗的时间来度量。</p><p>度量算法执行时间的方法：事后统计法，事前估计法</p><p>影响算法时间效率最主要因素是问题规模。</p><h2 id="2-线性表"><a class="anchor" href="#2-线性表">#</a> 2 线性表</h2><h3 id="21线性表的定义及基本操作"><a class="anchor" href="#21线性表的定义及基本操作">#</a> 2.1 线性表的定义及基本操作</h3><h3 id="22线性表的顺序存储"><a class="anchor" href="#22线性表的顺序存储">#</a> 2.2 线性表的顺序存储</h3><h4 id="1-数据结构定义"><a class="anchor" href="#1-数据结构定义">#</a> 1. 数据结构定义</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100   <span class="comment">//定义顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   ElemType data[MaxSize];</span><br><span class="line">   <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqlList;            <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><p></p><h4 id="2-基本操作"><a class="anchor" href="#2-基本操作">#</a> 2. 基本操作</h4><blockquote><p>插入操作</p></blockquote><ol><li>判断索引是否越界</li><li>判断元素个数是否大于最大长度</li><li><strong>索引 i 之后的元素往后移一位</strong></li><li>将元素 e 放入位置 i 处</li></ol><blockquote><p>删除操作</p></blockquote><ol><li>判断索引是否越界</li><li>删除索引 i 处的元素 e</li><li><strong>将 i 后边的元素向前移一位</strong></li></ol><h3 id="23线性表的链接存储"><a class="anchor" href="#23线性表的链接存储">#</a> 2.3 线性表的链接存储</h3><h4 id="1单链表"><a class="anchor" href="#1单链表">#</a> 1. 单链表</h4><h5 id="1数据结构定义"><a class="anchor" href="#1数据结构定义">#</a> 1. 数据结构定义</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;         <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>    <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p></p><h5 id="2-基本操作-2"><a class="anchor" href="#2-基本操作-2">#</a> 2. 基本操作</h5><blockquote><p>插入 —— 头插法</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2MyMDMwN2RjZmMxMDEyMjRhYWViNTJiMjY2ODJjNmYxLnBuZw==">image-20220919094648714</span></p><ul><li>将结点 s 插入到 a1 前面</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.next = L.next</span><br><span class="line">L.next = s</span><br></pre></td></tr></table></figure><p></p><blockquote><p>插入 —— 尾插法</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2ZlZjU1ZjFmNmVhMTk1Y2M5NjE3ODdmYzI1NDBmNjg5LnBuZw==">image-20220919094717108</span></p><ul><li>将结点 s 插到最后</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.next = s    <span class="comment">//r为指向尾结点的指针</span></span><br><span class="line">r = s    </span><br></pre></td></tr></table></figure><p></p><blockquote><p>删除操作</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzU2ZDdhYzkxZGIyYWVjOTc1MjQyYjVjOWE1ZTBiYWI2LnBuZw==">image-20220919094741430</span></p><ul><li>删除结点 p 后边的结点 q</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.next = p.next.next</span><br><span class="line"><span class="built_in">free</span>(q)</span><br></pre></td></tr></table></figure><p></p><h4 id="2-双链表"><a class="anchor" href="#2-双链表">#</a> 2. 双链表</h4><h5 id="1-数据结构定义-2"><a class="anchor" href="#1-数据结构定义-2">#</a> 1. 数据结构定义</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2YwYTc5NzY2OWYyMDMyZTVkODk4ZjNiZTZkZTc0YjcxLnBuZw==">image-20220919094135965</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;Dnode,*DLinkList;</span><br></pre></td></tr></table></figure><p></p><h5 id="2-基本操作-3"><a class="anchor" href="#2-基本操作-3">#</a> 2. 基本操作</h5><blockquote><p>插入操作</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzRjYTE5MzE2ZjQ5MjVkZTc2MDkxY2QxYTdjMmE4MzM4LnBuZw==">image-20220919094904951</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.next = p.next      <span class="comment">//第一步</span></span><br><span class="line">p.next.prior = s     <span class="comment">//第二步</span></span><br><span class="line">s.prior = p          <span class="comment">//第三步</span></span><br><span class="line">p.next  = s          <span class="comment">//第四步</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>删除操作</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2IwYjZmYzFkZDU4M2IzMjBjZjJhMmQ0ZTZkNGVmYzdjLnBuZw==">image-20220919100233234</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.next = q.next</span><br><span class="line">q.next.prior = p</span><br><span class="line"><span class="built_in">free</span>(q)</span><br></pre></td></tr></table></figure><p></p><h4 id="3-循环链表"><a class="anchor" href="#3-循环链表">#</a> 3. 循环链表</h4><blockquote><p>循环单链表</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzExOGM0ODNkOGZmZGM0Mjg2NzdjZjIzY2RiMGM4YTI2LnBuZw==">image-20220919100512832</span></p><blockquote><p>循环双链表</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2I5ZGY4MTMwMjM3MjZhNjcyM2IyNjQzZjM2NGMxMzIwLnBuZw==">image-20220919100540976</span></p><h4 id="4静态链表"><a class="anchor" href="#4静态链表">#</a> 4. 静态链表</h4><h5 id="1-概念"><a class="anchor" href="#1-概念">#</a> 1. 概念</h5><ul><li>静态链表是借助数组来描述线性表的链式存储结构</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0Lzc0NWFiYjhhMzk1YWYzYWM4OTRjY2FkMjc1NjI4OGFkLnBuZw==">image-20220919100729273</span></p><h5 id="2-数据结构"><a class="anchor" href="#2-数据结构">#</a> 2. 数据结构</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;      <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure><p></p><h2 id="3-栈和队列"><a class="anchor" href="#3-栈和队列">#</a> 3 栈和队列</h2><h3 id="31栈和队列的基本概念"><a class="anchor" href="#31栈和队列的基本概念">#</a> 3.1 栈和队列的基本概念</h3><h3 id="32栈和队列的顺序存储结构"><a class="anchor" href="#32栈和队列的顺序存储结构">#</a> 3.2 栈和队列的顺序存储结构</h3><h4 id="1-栈的顺序存储"><a class="anchor" href="#1-栈的顺序存储">#</a> 1. 栈的顺序存储</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                 <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p></p><h4 id="2-栈的基本操作"><a class="anchor" href="#2-栈的基本操作">#</a> 2. 栈的基本操作</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2Y2M2MzYjgzNmNjNmZhOTYwMjUzMTI4Mzc1M2Q2NzgzLnBuZw==">image-20220919101728348</span></p><ul><li>初始化时栈顶指针 top 指向 -1</li></ul><blockquote><p>入栈</p></blockquote><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.data[++S.top] = x; <span class="comment">//指针先加1，再入栈</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>出栈</p></blockquote><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = S.data[S.top--]; <span class="comment">//先出栈，指针再减1 </span></span><br></pre></td></tr></table></figure><p></p><h4 id="3共享栈"><a class="anchor" href="#3共享栈">#</a> 3. 共享栈</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2E3ZTA4NDE0YmJlYTQ2ZjIxMmJlNjQ4NGIyYzI5YTQ2LnBuZw==">image-20220919102322840</span></p><p>两个栈的栈顶指针都指向栈顶元素，top0=-1 时 0 号栈为空，top1=MaxSize 时 1 号栈为空；仅当两个栈顶指针相邻 (top1-top0=1）时，判断为栈满。当 0 号栈进栈时 top0 先加 1 再赋值，1 号栈进栈时 top1 先减 1 再赋值：出栈时则刚好相反。</p><h4 id="4-队列的顺序存储"><a class="anchor" href="#4-队列的顺序存储">#</a> 4. 队列的顺序存储</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;     <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p></p><ul><li>初始状态（队空条件)：Q.front== Q.rear ==0。</li><li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1。</li><li>出队操作：队不空时，先取队头元素值，再将队头指针加 1。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2VjOGQ5NTMxNTg4MzEzYWE0MGJlOWVhYmQxYTc5NWEwLnBuZw==">image-20220919103608190</span></p><h4 id="5循环队列"><a class="anchor" href="#5循环队列">#</a> 5. 循环队列</h4><blockquote><p>区分队满和队空的三种方法</p></blockquote><p>三种方法进栈，入栈操作都一样</p><ul><li>进栈：队尾指针进 1——Q.rear = (Q.rear+1)% MaxSize</li><li>出栈：队首指针进 1——Q.front = (Q.front+1)% MaxSize</li></ul><ol><li>牺牲一个存储单元</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2E5YzI2NDc4ODg3NTNlNGFmMzc3ODhhY2JkMDM3NGM5LnBuZw==">image-20220919104528598</span></p><ul><li>队满条件： (Q.rear+1)% MaxSize == Q.front。</li><li>队空条件：Q.front==Q.rear</li><li>队列中元素的个数: (Q.rear－Q.front+MaxSize) % Maxsize。</li></ul><ol start="2"><li>类型中增设表示元素个数的数据成员。这样，队空的条件为 Q.size=0; 队满的条件为 Q.size=MaxSize。这两种情况都有 Q.front=Q.rear</li><li>类型中增设 tag 数据成员，以区分是队满还是队空。tag 等于 0 时，若因删除导致 Q.front=Q.rear，则为队空；tag 等于 1 时，若因插入导致 Q.front==Q.rear, 则为队满。</li></ol><h3 id="33栈和队列的链式存储结构"><a class="anchor" href="#33栈和队列的链式存储结构">#</a> 3.3 栈和队列的链式存储结构</h3><h4 id="1-栈的链式存储"><a class="anchor" href="#1-栈的链式存储">#</a> 1. 栈的链式存储</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzViYzExY2M4MmQ5YmQ3NTJmYWY5ODE0NTgxZTJmNTFiLnBuZw==">image-20220919102447029</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LiStack;</span><br></pre></td></tr></table></figure><p></p><ul><li>出栈和进栈都在链表的表头进行</li></ul><h4 id="2-队列的链式存储"><a class="anchor" href="#2-队列的链式存储">#</a> 2. 队列的链式存储</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>         <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                 <span class="comment">//链式队列</span></span><br><span class="line">     LinkNode *front,*rear;     <span class="comment">//队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p></p><ul><li>队列判空</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q.front = Q.rear</span><br></pre></td></tr></table></figure><p></p><ul><li>入队</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新结点s</span></span><br><span class="line">Q.rear-&gt;next = s</span><br><span class="line">Q.rear = s</span><br></pre></td></tr></table></figure><p></p><ul><li>出队</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkNode *p = Q.front-&gt;next;       <span class="comment">//p为队列的第一个结点，Q.front指向头结点</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == p)&#123;                 <span class="comment">//队列中只有一个元素</span></span><br><span class="line">    Q.rear = Q.front;             <span class="comment">//队尾指针指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p></p><h4 id="3-双端队列"><a class="anchor" href="#3-双端队列">#</a> 3. 双端队列</h4><p>双端队列是指允许两端都可以进行入队和出队操作的队列。</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzVlNDU0NDg2ZGYwZTM5NTA1MWY0NDdlZWQwMzVhNDIxLnBuZw==">image-20220919110919339</span></p><ul><li>输出受限的双端队列</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzQ2MzFmOTFiMTU3ZGZhY2Y0ZjUwMTYwNTIxMzhkOGVlLnBuZw==">image-20220919111010794</span></p><ul><li>输入受限的双端队列</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2RiOGI5ODZiYjNiZWFkYTlkYThmMGZiZjc5NjNhYmU0LnBuZw==">image-20220919111110381</span></p><h3 id="34表达式计算栈"><a class="anchor" href="#34表达式计算栈">#</a> 3.4 表达式计算（栈）</h3><p>中缀表达式，后缀表达式，前缀表达式</p><h3 id="35递归栈"><a class="anchor" href="#35递归栈">#</a> 3.5 递归（栈）</h3><p>将递归算法变为非递归算法</p><h2 id="4-数组"><a class="anchor" href="#4-数组">#</a> 4 数组</h2><h3 id="41数组的基本概念"><a class="anchor" href="#41数组的基本概念">#</a> 4.1 数组的基本概念</h3><h3 id="42特殊矩阵"><a class="anchor" href="#42特殊矩阵">#</a> 4.2 特殊矩阵</h3><h4 id="1-对称矩阵的压缩存储"><a class="anchor" href="#1-对称矩阵的压缩存储">#</a> 1. 对称矩阵的压缩存储</h4><ul><li>按行优先，下标从 0 开始</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2I2NmZiYzMyNTNmNmZhY2M1YmQyNTdlMjYzNGJlYjViLnBuZw==">image-20220920092159201</span></p><h4 id="2-三角矩阵的压缩存储"><a class="anchor" href="#2-三角矩阵的压缩存储">#</a> 2. 三角矩阵的压缩存储</h4><ul><li>下三角矩阵（按行优先，下标从 0 开始）</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzNlOTk4NzFjZDFiMWJjZGM1MTUxMWIxNWRhMmNhNWZiLnBuZw==">image-20220920092627208</span></p><ul><li>下三角矩阵（按行优先，下标从 0 开始）</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzJhMDVlNjE1Y2M1ODUzODg4MWIxMjZlZjk0MjA4ZWUzLnBuZw==">image-20220920093712556</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzAzODc1NGU4YzM0ZmM3YWJhZDEzNTBiMjg3MGFhYjFiLnBuZw==">image-20220920093728064</span></p><h4 id="3三对角矩阵"><a class="anchor" href="#3三对角矩阵">#</a> 3. 三对角矩阵</h4><ul><li>按行优先，下标从 0 开始</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2Q1MmU0Mzc0ODEyYTUzODFiOTczZjU1NTBiYjFlZjg4LnBuZw==">image-20220920094054711</span></p><h3 id="43稀疏矩阵"><a class="anchor" href="#43稀疏矩阵">#</a> 4.3 稀疏矩阵</h3><ul><li>将非零元素及相应的行和列构成一个三元组（行标，列表，值）</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2ZjMzY4ZDFhZjQxNzljNTFiMGYxOGE2NTViZDJjY2UzLnBuZw==">image-20220920094332301</span></p><ul><li>可以按行优先（行三元组表）或者列优先（列三元组表）存在在一个三元组中。</li><li>稀疏矩阵快速转置算法所需的 num 数组与 k 数组<ol><li>num [j] 统计稀疏矩阵 A 中列号为 j 的<mark>非零元素</mark>个数</li><li>k [j] 统计稀疏矩阵 A 中列号从 0 到 j-1 的非零元素个数之和。</li></ol></li></ul><h2 id="5-树和二叉树"><a class="anchor" href="#5-树和二叉树">#</a> 5 树和二叉树</h2><h3 id="51树的基本概念"><a class="anchor" href="#51树的基本概念">#</a> 5.1 树的基本概念</h3><ul><li><p>度为 m 的树中第 i 层上至多有 m^(i-1) 个节点</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0Lzk3NDNiMTBmM2JlYjYyMWUzMzI5OTkzYzNiMjhmODFmLnBuZw==">image-20220920094849460</span></p></li></ul><h3 id="52二叉树"><a class="anchor" href="#52二叉树">#</a> 5.2 二叉树</h3><h4 id="521二叉树的定义及主要特征"><a class="anchor" href="#521二叉树的定义及主要特征">#</a> 5.2.1 二叉树的定义及主要特征</h4><ul><li>非空二叉树上的叶子结点数等于度为 2 的结点数加 1，即 n0 =n2 + 1。</li><li>非空二叉树上第 k 层上至多有 2^(k-1) 个结点 (k≥1)。</li><li>高度为 h 的二叉树至多有 2^h - 1 个结点（h≥1)。</li><li><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzAxNDVhMjM3M2U4MzQ3YTBiNzAzMTE0NTAwMjUxMDRmLnBuZw==">image-20220920095444503</span></li></ul><h4 id="522二叉树的顺序存储和链式存储"><a class="anchor" href="#522二叉树的顺序存储和链式存储">#</a> 5.2.2 二叉树的顺序存储和链式存储</h4><h5 id="1-顺序存储"><a class="anchor" href="#1-顺序存储">#</a> 1. 顺序存储</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzA3ODM2YzlhYjE3MGJlNWMxMzcwOTczNTkyMDdjNDE1LnBuZw==">image-20220920100110230</span></p><h5 id="2链式存储"><a class="anchor" href="#2链式存储">#</a> 2. 链式存储</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2UyNDQ1YzdmYmE4MWEwZjZiZjNhNDAzOGJlZTk2MDg0LnBuZw==">image-20220920100214079</span></p><ul><li>链式数据结构定义</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//左，右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p></p><p><mark>在含有 n 个结点的二叉链表中，含有 n+1 个空链域</mark></p><h4 id="523二叉树的遍历"><a class="anchor" href="#523二叉树的遍历">#</a> 5.2.3 二叉树的遍历</h4><h5 id="1先序遍历"><a class="anchor" href="#1先序遍历">#</a> 1. 先序遍历</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T=null)&#123;</span><br><span class="line">        visit(I);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="2中序遍历"><a class="anchor" href="#2中序遍历">#</a> 2. 中序遍历</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T=null)&#123;</span><br><span class="line">        visit(I);</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(I);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="3后序遍历"><a class="anchor" href="#3后序遍历">#</a> 3. 后序遍历</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T=null)&#123;</span><br><span class="line">        visit(I);</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(I);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="4-层次遍历"><a class="anchor" href="#4-层次遍历">#</a> 4. 层次遍历</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);        <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);        <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);    <span class="comment">//删除队头元素，并用p返回（赋值给p）</span></span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild=null)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">         <span class="keyword">if</span> (p-&gt;rchild=null)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="524-线索二叉树的基本概念和构造"><a class="anchor" href="#524-线索二叉树的基本概念和构造">#</a> 5.2.4 线索二叉树的基本概念和构造</h4><blockquote><p>概念</p></blockquote><p>线索二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。</p><p><strong>引入线索二叉树是为了加快查找结点前驱和后继的速度</strong></p><blockquote><p>构造</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2EwZjMwZTY0ZThmYzU1MWQ4MDMxNGY3M2E0NWVmYjM1LnBuZw==">image-20220920104922000</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2U0YjM2YjJiOThmZDQ2ZjE4MDc4MTQ4OWM4YTI4ZTJjLnBuZw==">image-20220920104939458</span></p><blockquote><p>数据结构</p></blockquote><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>通过中序遍历对二叉树线索化</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2VlMmEwODU5YmFlZTk2YmJmNjM0NGQwNTBhNWE0ZTdjLnBuZw==">image-20220920105715332</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inthread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p=null)&#123;</span><br><span class="line">        Inthread(p-&gt;lchild,pre);    <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;  <span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">        Inthread(p-&gt;rchild,pre);     <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>通过中序遍历建立中序搜索二叉树</p></blockquote><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    ThreadTree pre = null;</span><br><span class="line">    <span class="keyword">if</span> (T=null)&#123;</span><br><span class="line">        Inthread(T,pre);           <span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="53树和森林"><a class="anchor" href="#53树和森林">#</a> 5.3 树和森林</h3><h4 id="531树的存储结构"><a class="anchor" href="#531树的存储结构">#</a> 5.3.1 树的存储结构</h4><h5 id="1双亲表示法"><a class="anchor" href="#1双亲表示法">#</a> 1. 双亲表示法</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2VlYzJhMDg4MmJhYjNhNjIwNDAxYjViNjkwNGM0MWE3LnBuZw==">image-20220920110932973</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100     <span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;              <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n;                  <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p></p><p>该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但求结点的孩子时需要遍历整个结构。</p><h5 id="2孩子表示法"><a class="anchor" href="#2孩子表示法">#</a> 2. 孩子表示法</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0Lzc2Y2M3NGQ5Y2M3OWUxNmM4NGUzMDVkNzY3ZjE1NTRmLnBuZw==">image-20220920112245285</span></p><p>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 n 个结点中孩子链表指针域所指向的 n 个孩子链表。</p><h5 id="3孩子兄弟表示法左孩子右兄弟"><a class="anchor" href="#3孩子兄弟表示法左孩子右兄弟">#</a> 3. 孩子兄弟表示法（左孩子，右兄弟）</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2I2YzdiYjUyN2Q0M2E0MzdkODk0YmY0OTMzOTZhNTNkLnBuZw==">image-20220920112615626</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">     Elemtype data;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">CSNOde</span> *<span class="title">nextchild</span>,*<span class="title">nextsibling</span>;</span> </span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p></p><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。</p><h4 id="532森林和二叉树的转换"><a class="anchor" href="#532森林和二叉树的转换">#</a> 5.3.2 森林和二叉树的转换</h4><ol><li>将森林中每棵树转换成二叉树（左孩子右兄弟）</li><li>将第二个二叉树插到 第一个二叉树的右孩子处，以此类推</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzQyNDRiZGFmOTZmY2Y5YWYyMzY5M2MzYTkxMTg5ZjUwLnBuZw==">image-20220920113245580</span></p><h4 id="533树和森林的遍历"><a class="anchor" href="#533树和森林的遍历">#</a> 5.3.3 树和森林的遍历</h4><p>树的后根遍历也叫做中根遍历</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzBlODJlMWJiYmEwMGE3ZjBhY2VmMzNlZjdhOTIyMGY2LnBuZw==">image-20220920113534100</span></p><h3 id="54树和二叉树的应用"><a class="anchor" href="#54树和二叉树的应用">#</a> 5.4 树和二叉树的应用</h3><h4 id="541二叉排序树"><a class="anchor" href="#541二叉排序树">#</a> 5.4.1 二叉排序树</h4><h5 id="1查找"><a class="anchor" href="#1查找">#</a> 1. 查找</h5><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BSTNOde *<span class="title function_">BST_Search</span><span class="params">(BiTree T,ElemType key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T=<span class="literal">NULL</span> &amp;&amp; T-&gt;data=key)&#123;</span><br><span class="line">        <span class="keyword">if</span> (key&lt;T-&gt;data)</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="2插入"><a class="anchor" href="#2插入">#</a> 2. 插入</h5><ul><li>插入的结点一定是一个新添加的叶结点</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree &amp;T,KeyType k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==null)&#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;data = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = null;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k==T-&gt;data)&#123;  <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k&lt;T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="3删除"><a class="anchor" href="#3删除">#</a> 3. 删除</h5><ul><li>叶结点，直接删除</li><li>只有一颗左（右）子树，直接删除，左（右）子树接替</li><li>左右子树都有，让结点 z 的直接后继（或直接前驱）代替 z，然后在子树中删除直接后继，变为第一或第二种情况</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2JkODVlMWNiM2M2YzJhMWJhNWQ4NGQ5YzVjOWNiNGFiLnBuZw==">image-20220921085318354</span></p><h5 id="4-查找性能"><a class="anchor" href="#4-查找性能">#</a> 4. 查找性能</h5><ul><li>二叉排序树的查找效率主要取决于树的高度。</li><li>平均查找长度为 O (log2n)，最坏情况下平均查找长度为 O (n)</li></ul><h4 id="542-平衡二叉树"><a class="anchor" href="#542-平衡二叉树">#</a> 5.4.2 平衡二叉树</h4><ul><li>平均查找长度为 O (log2n)</li></ul><h5 id="1-插入"><a class="anchor" href="#1-插入">#</a> 1. 插入</h5><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzkzN2YxNzg4YjY1M2I5YmJlZTQ5MzBmOTZlM2UyODk3LnBuZw==">image-20220921090129561</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2ZjNzBlZTM5MmY1YWFmM2Q2NWY2NzIxZGJjMzY1NjNjLnBuZw==">image-20220921090242165</span></p><p>例：以关键字序列 {16,3,7,11,9,26,18,14,15} 构造一颗 AVL 树（二叉平衡树）</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2NmZjMzZDRiNThlNjUwZWY5ZjJhOGFjY2UxNmM1OTY0LnBuZw==">image-20220921091004360</span></p><h4 id="543哈夫曼huffman树和哈夫曼编码"><a class="anchor" href="#543哈夫曼huffman树和哈夫曼编码">#</a> 5.4.3 哈夫曼 (Huffman) 树和哈夫曼编码</h4><blockquote><p>哈夫曼树的构造</p></blockquote><p>给定 n 个权值分别为 W1, W2,……,Wn 的结点，构造哈夫曼树的算法描述如下:</p><ol><li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F。</li><li>构造一个新结点，从 F 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从 F 中删除刚才选出的两棵树，同时将新得到的树加入 F 中。</li><li>重复步骤 2 和 3，直至 F 中只剩下一棵树为止。</li></ol><h2 id="6-图"><a class="anchor" href="#6-图">#</a> 6 图</h2><h3 id="61图的基本概念"><a class="anchor" href="#61图的基本概念">#</a> 6.1 图的基本概念</h3><h3 id="62图的存储及基本操作"><a class="anchor" href="#62图的存储及基本操作">#</a> 6.2 图的存储及基本操作</h3><h4 id="621邻接矩阵法"><a class="anchor" href="#621邻接矩阵法">#</a> 6.2.1 邻接矩阵法</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0Lzk1NGE3ZTVhNWZiMjhlOGM5NDNkMDljNTQwN2VlMTE3LnBuZw==">image-20220921091647501</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100      <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;      <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType          <span class="comment">//带权图边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];    <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;        <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzMzYmM4MTEzNzYzYjY1ZTc1MjExODc0YjMzNWM1NzJmLnBuZw==">image-20220921092245382</span></p><h4 id="622邻接表表示法"><a class="anchor" href="#622邻接表表示法">#</a> 6.2.2 邻接表表示法</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100      <span class="comment">//图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>       <span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;              </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>    </span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>        <span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;         <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;          <span class="comment">//指向第一条以赴该节点的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;    <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;   <span class="comment">//图中顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><p></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzA1MmE1NGQ5NGI0NmY4MzAxZTE0Zjc1MmE3YzZiNTg0LnBuZw==">image-20220921093723288</span></p><h3 id="63图的遍历"><a class="anchor" href="#63图的遍历">#</a> 6.3 图的遍历</h3><h4 id="631深度优先搜索"><a class="anchor" href="#631深度优先搜索">#</a> 6.3.1 深度优先搜索</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX VERTEX NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;   <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;   <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    InitQueue (Q);          <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum; ++i)<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i])     <span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);       <span class="comment">//vi未访问过,从vi开始BFS</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span>&#123; <span class="comment">//从顶点v出发,广度优先遍历图G</span></span><br><span class="line">    visit(v);             <span class="comment">//访问初始顶点V</span></span><br><span class="line">    visited[v]=TRUE;      <span class="comment">//对v做已访问标记</span></span><br><span class="line">    Enqueue(Q, v);        <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(isEmpty (Q))&#123;</span><br><span class="line">        DeQueue(Q, v);    <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))&#123;      <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visited[w])&#123; <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            visit(w);        <span class="comment">//访问顶点w</span></span><br><span class="line">            visited[w]=TRUE; <span class="comment">//对w做已访问标记</span></span><br><span class="line">            EnQueue(Q,w);    <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>性能分析</p></blockquote><ul><li>最坏情况下，空间复杂度 O (|V|)</li><li>采用领接表存储，时间复杂度为 O (|V|+|E|)。采用邻接矩阵存储，时间复杂度为 O (|V|^2)</li></ul><h4 id="632广度优先搜索"><a class="anchor" href="#632广度优先搜索">#</a> 6.3.2 广度优先搜索</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];      <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;        <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">       visited[v] =FALSE;          <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>;v&lt;G.vexnum;++v)       <span class="comment">//本代码中是从v=0开始遍历</span></span><br><span class="line">       <span class="keyword">if</span> (visited[v])</span><br><span class="line">          DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;         <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v) ;                    <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=TRUE;              <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">    <span class="keyword">if</span> (visited[w])              <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">        DFS(G,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>性能分析</p></blockquote><ul><li>空间复杂度 O (|V|)</li><li>采用领接表存储，时间复杂度为 O (|V|+|E|)。采用邻接矩阵存储，时间复杂度为 O (|V|^2)</li></ul><h3 id="64图的基本应用"><a class="anchor" href="#64图的基本应用">#</a> 6.4 图的基本应用</h3><h4 id="641拓扑排序"><a class="anchor" href="#641拓扑排序">#</a> 6.4.1 拓扑排序</h4><blockquote><p>步骤</p></blockquote><ol><li>从 AOV 网中选择一个没有前驱的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复①和②直到当前的 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><blockquote><p>算法实现</p></blockquote><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Topologicalsort</span> <span class="params">(Graph G)</span>&#123;</span><br><span class="line">    InitStack(S);    <span class="comment">//初始化栈,存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">      <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">        Push(s,i);   <span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;     <span class="comment">//计数,记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(IsEmpty(S))&#123;     <span class="comment">//栈不空,则存在入度为0的顶点</span></span><br><span class="line">        Pop (s,i);          <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++]=i;   <span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">        <span class="comment">//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S</span></span><br><span class="line">            v=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>((--indegree[v]))</span><br><span class="line">               Push (s,v);    <span class="comment">//入度为0.入栈</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count&lt;G.vexnum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">//拓扑排序成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzZlNDU5ZmM1Mzc2YmE4MmM5MWYzODRhMjg4MzY0ZmZjLnBuZw==">image-20220921102730530</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2M0ZGExOTFmN2NkYTEyNDYyNDNmMTE5MWYyNjRhMDZhLnBuZw==">image-20220921102749943</span></p><h4 id="642关键路径"><a class="anchor" href="#642关键路径">#</a> 6.4.2 关键路径</h4><ul><li>正向找最大，反向找最小</li><li>最早时间 = 最晚时间 ：关键路径</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzZhYzEyNDU3MzYwYzQ4ZTVmZjdhNDFkNzg2OTY4YjFjLnBuZw==">image-20220921104759547</span></p><h4 id="643-最小代价生成树"><a class="anchor" href="#643-最小代价生成树">#</a> 6.4.3 最小代价生成树</h4><h5 id="1prim算法"><a class="anchor" href="#1prim算法">#</a> 1.Prim 算法</h5><p>初始时从图中任取一顶点（如顶点 1）加入树 T，此时树中只含有一个顶点，之后选择一个与当前 T 中顶点集合距离最近的顶点，并将该顶点和相应的边加入 T，每次操作后 T 中的顶点数和边数都增 1。以此类推，直至图中所有的顶点都并入 T，得到的 T 就是最小生成树。此时 T 中必然有 n-1 条边。</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzcyYTQwZmZhNGE5ZTA5MGNlZmQ0NzI5MDZkYzU3YTQ3LnBuZw==">image-20220921100546087</span></p><h5 id="2kruskal算法"><a class="anchor" href="#2kruskal算法">#</a> 2.Kruskal 算法</h5><p>初始时为只有 n 个顶点而无边的非连通图 T= {V,{}}，每个顶点自成一个连通分量，然后<mark>按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</mark>，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入 T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至 T 中所有顶点都在一个连通分量上。</p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0Lzg1ZWMwNGVmOGQzYmFmNDE5N2ZkYmY4YzliMWE4NjY1LnBuZw==">image-20220921100821070</span></p><h4 id="644最短路径"><a class="anchor" href="#644最短路径">#</a> 6.4.4 最短路径</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2MyZjMzMmZiZDY3OTk3MzczYjYxMWEzNTQzNGZmN2JjLnBuZw==">image-20220921101736790</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzE5YjNjYWZiMjkzYzVhYmQyMTNlZDk4YTAxYjFlMjJkLnBuZw==">image-20220921102425462</span></p><h2 id="7-搜索search"><a class="anchor" href="#7-搜索search">#</a> 7 搜索（Search）</h2><h3 id="71搜索的基本概念"><a class="anchor" href="#71搜索的基本概念">#</a> 7.1 搜索的基本概念</h3><h3 id="72顺序搜索法"><a class="anchor" href="#72顺序搜索法">#</a> 7.2 顺序搜索法</h3><p>王海艳数据结构版</p><h4 id="1无序表的顺序搜索"><a class="anchor" href="#1无序表的顺序搜索">#</a> 1. 无序表的顺序搜索</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search</span><span class="params">(listSet L,ElemType x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (L.element[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>搜索成功的情况下平均查找长度 ASL = (n+1)/2</li><li>搜索失败的情况下平均查找长度 ASL = n</li></ul><h4 id="2-有序表的顺序搜索"><a class="anchor" href="#2-有序表的顺序搜索">#</a> 2. 有序表的顺序搜索</h4><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search</span><span class="params">(listSet L,ElemType x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;L.element[i]&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (L.element[i]==x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>搜索成功的情况下平均查找长度 ASL = (n+1)/2</li><li>搜索失败的情况下平均查找长度 ASL = n/2+2</li></ul><h3 id="73二分搜索法"><a class="anchor" href="#73二分搜索法">#</a> 7.3 二分搜索法</h3><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Binary <span class="title function_">Search</span><span class="params">(SeqList L,ElemType key)</span></span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>.(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;   <span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] ==key)</span><br><span class="line">           <span class="keyword">return</span> mid;      <span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">           high=mid<span class="number">-1</span>;      <span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           low=mid+<span class="number">1</span>;       <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;               <span class="comment">//查找失败,返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><p>时间复杂度为 O (log2n)</p></li><li><p>判定树</p></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2YwNGVmNTk2ZDNkN2E0MjE2YzMwOTZlNzFmMmVjOThlLnBuZw==">image-20220921111436093</span></p><p>在等概率情况下，查找成功 (圆形结点) 的 ASL=(1×1+2×2＋3x4＋4×4)/11 =3，查找不成功（方形结点）的 ASL=(3x4＋4x8)/12= 11/3。</p><h3 id="74-b-树及其基本操作"><a class="anchor" href="#74-b-树及其基本操作">#</a> 7.4 B - 树及其基本操作</h3><blockquote><p>B 树适用于外搜索的理由</p></blockquote><p>B 树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小、充分利用了磁盘预读的功能。每次读取磁盘页时就会读取整个节点。也正因每个节点存储着非常多个关键字、树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p><h4 id="1插入"><a class="anchor" href="#1插入">#</a> 1. 插入</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2VlMDQzNTc5NzcyZWExNTQ4ZWZiNGE1NjAzYzE2MTBhLnBuZw==">image-20220921113634166</span></p><h4 id="2-删除"><a class="anchor" href="#2-删除">#</a> 2. 删除</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzRkNjRhMDMwOWU2NzJmOGMyYTI2ZmNjNzY0ODk3ZjQ5LnBuZw==">image-20220921113943110</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2FkNzBlMTI4MTgxMmZkMDM1ODg3OWExNjk1ZThhYTM5LnBuZw==">image-20220921113957628</span></p><h4 id="3-b-树的特性"><a class="anchor" href="#3-b-树的特性">#</a> 3. B - 树的特性</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzZjM2M1ZWZmODQ5ZGU3YTgwYWIwNDU5MjdmYzJiYjNmLnBuZw==">image-20220921114124493</span></p><h3 id="75散列hash表"><a class="anchor" href="#75散列hash表">#</a> 7.5 散列 (Hash) 表</h3><h4 id="1概念"><a class="anchor" href="#1概念">#</a> 1. 概念</h4><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 Hash (key)=Addr</p><p>散列 (Hash) 表：根据关键字而直接进行访问的数据结构。</p><p>常用的散列函数:</p><ol><li>直接定址法：H (key)=a x key + b</li><li>除留余数法：H (key)=key % p</li><li>平方取中法</li><li>折叠法：将关键字值从左到右划分成位数相等的若干个部分值（位数与散列地址位数相等），部分值叠加，获得散列地址。如果计算结果超过地址位数，则将最高位去掉。</li></ol><p>处理冲突的方法:</p><ol><li><p>开放定址法<br>取定某一增量序列后，对应的处理方法就是确定的。通常有以下 4 种取法：</p><p>①线性探测法。<br>②平方探测法 (<mark>二次探测法</mark>)<br>③再散列法<br>④伪随机序列法</p></li><li><p>拉链法</p></li></ol><h4 id="2-线性探测法"><a class="anchor" href="#2-线性探测法">#</a> 2. 线性探测法</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2NjNWU1N2Y5NjQ3N2NmYmQzZjc4Mjg5MDNhZmY3N2JiLnBuZw==">image-20220921114829925</span></p><h4 id="3平方散列法"><a class="anchor" href="#3平方散列法">#</a> 3. 平方散列法</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2QwNWI0ODJkZDFmMjMxZjdjOTY0YWNmYmNjMjAxYzI4LnBuZw==">image-20220921115324253</span></p><h4 id="4-再散列法双散列法"><a class="anchor" href="#4-再散列法双散列法">#</a> 4. 再散列法（双散列法）</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzhkNDhlZTI3OTk2MDFmOGVkZTgzYmY5YmM0OWViMmY3LnBuZw==">image-20220921115942319</span></p><ul><li><mark>易错：第二个散列函数是下一个探测地址的增量</mark></li></ul><h4 id="5-伪随机序列法"><a class="anchor" href="#5-伪随机序列法">#</a> 5. 伪随机序列法</h4><p>当 di = 伪随机数序列时，称为伪随机序列法。</p><h4 id="6拉链法"><a class="anchor" href="#6拉链法">#</a> 6. 拉链法</h4><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzkzMzgwOWFkOTVlOTIxMTIyZjcyYTk1YzU4MTc1ODQ0LnBuZw==">image-20221031111156221</span></p><ul><li>ASL 失败 = （2+3+1+0+0+2+0+0+0+0+0）/11 = 8/11 (王道书上的方法，以这个为准)</li></ul><h3 id="76搜索算法的分析及应用"><a class="anchor" href="#76搜索算法的分析及应用">#</a> 7.6 搜索算法的分析及应用</h3><h2 id="8-内排序"><a class="anchor" href="#8-内排序">#</a> 8 内排序</h2><h3 id="81排序的基本概念"><a class="anchor" href="#81排序的基本概念">#</a> 8.1 排序的基本概念</h3><h3 id="82简单选择排序"><a class="anchor" href="#82简单选择排序">#</a> 8.2 简单选择排序</h3><ul><li>选择最小元素，放在队列前端</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzJlNTU0YjZlZGM1ZWNiNzYwNzExZDg2NTFiMzMwYTNmLnBuZw==">image-20220921163727171</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         min=i;</span><br><span class="line">        <span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]&lt;A[min])</span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min=i)</span><br><span class="line">            swap(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="83直接插入排序"><a class="anchor" href="#83直接插入排序">#</a> 8.3 直接插入排序</h3><ul><li>一个一个往前移</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2MzZjhmNjQ5OGJiMTcyYzQ1OTgwYWE3YWEwMzY3OGU3LnBuZw==">image-20220921163638212</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">           A[<span class="number">0</span>]=A[i];               <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">           <span class="keyword">for</span> (j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)<span class="comment">//找到最后一个比A[0]的元素   </span></span><br><span class="line">               A[j+<span class="number">1</span>] = A[j];       <span class="comment">//依次往后移</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];          <span class="comment">//将A[0]插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="84冒泡排序bubble-sort"><a class="anchor" href="#84冒泡排序bubble-sort">#</a> 8.4 冒泡排序 (bubble sort)</h3><ul><li>一个一个比较</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzUwYjQ4MWIwMWMyZWQyOWQ4ZDIzZmIzYzZjMmY0YmI2LnBuZw==">image-20220921165307850</span></p><ul><li>下边代码是每趟排序选出一个最小位置，与上图过程不一致</li></ul><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span> (A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag = <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;           <span class="comment">//本趟遍历没有发生交换，说明已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="85希尔排序shell-sort"><a class="anchor" href="#85希尔排序shell-sort">#</a> 8.5 希尔排序 (shell sort)</h3><ul><li>增量之间的插入排序（常用增量）</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzE1MDE2NzdhYmNlMGE1NWM1ZWIyZmVmZGQxNzdmZDNjLnBuZw==">image-20220921170125199</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">void</span> <span class="title function_">sort</span><span class="params">(Comparabel[] a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=a.length;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h&lt;len/<span class="number">2</span>)</span><br><span class="line">        h=<span class="number">2</span>*h+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&gt;=h &amp;&amp; less(a[j],a[j-h]);j-=h)</span><br><span class="line">                exch(a,j,j-h);</span><br><span class="line">        &#125;</span><br><span class="line">        h=h/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="86快速排序"><a class="anchor" href="#86快速排序">#</a> 8.6 快速排序</h3><blockquote><p>王道</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzM3NjkwMjVjOGNkZDQwMmQ0MzAwNzU2OTU3NmFhNWMyLnBuZw==">image-20220921171940038</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzQ4OWM3MWQ4MWIxYTdmZjMzNjkyNmM2NmY4YjVkNjA0LnBuZw==">image-20220921172005033</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span> <span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;   <span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="comment">//Partition ()就是划分操作，将表A[low…high]划分为满足上述条件的两个子表</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low, high); <span class="comment">//划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>); <span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        QuickSort(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123; <span class="comment">//一趟划分</span></span><br><span class="line">    ElemType pivot=A [low];<span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;       <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) </span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];   <span class="comment">//将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot) </span><br><span class="line">            ++low;</span><br><span class="line">        A[high]=A[low]; <span class="comment">//将比枢轴大的元素移动到右端</span></span><br><span class="line">        A[low]=pivot;   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">        <span class="keyword">return</span> low;     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>南邮</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzE4NDdiNGVlMGNmNGY0NTJhYjBmMzFmN2Y5ZTQzMjRhLnBuZw==">image-20221205113630535</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2QwODI5YTVkOTEzMjgzY2U4NzJiNzEyNGEwZTQwYTBjLnBuZw==">image-20221205113721395</span></p><ul><li>示例</li></ul><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">待排序序列 48  36  68  72  12  48  02</span><br><span class="line">第一趟    (12  36  02  48)  48  (72  68) </span><br><span class="line">第二趟    (02)  12  (36  48)  48  (72  68)       对左边进行排序</span><br><span class="line">第三趟    02  12  36  48  48  72  68             对（36,48）进行排序 </span><br><span class="line">第四趟    02  12  36  48  48  68  72             对右边进行排序</span><br></pre></td></tr></table></figure><p></p><h3 id="87堆排序"><a class="anchor" href="#87堆排序">#</a> 8.7 堆排序</h3><ul><li>①建堆 ②m/2 ③建大根堆 ④与最后一个换</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzNjNjlkYjZhODMxYzU3NWUzYjU1MmM1MjQ2MDY4OWM3LnBuZw==">image-20220921172714370</span></p><h3 id="88两路合并排序merge-sort"><a class="anchor" href="#88两路合并排序merge-sort">#</a> 8.8 两路合并排序 (merge sort)</h3><ul><li>分组再结合</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzFjY2I4Mzc1YzY3YTM2YWVhYjU5ZWZkYTRkN2M4ZmM4LnBuZw==">image-20220922090326830</span></p><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将前后两个相邻的顺序表合成一个</span></span><br><span class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElemType));   <span class="comment">//辅助数组B</span></span><br><span class="line"><span class="comment">//A[low,mid],A[mid+1,high]有序，将他们两个合并到一起</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=low;k&lt;=high;k++)&#123;</span><br><span class="line">        B[k]=A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i]&lt;B[j])</span><br><span class="line">            A[k]=B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">        A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">        A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(A,low,mid);</span><br><span class="line">        MergeSOrt(A,mid+<span class="number">1</span>,high);</span><br><span class="line">        merge(A,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="89基数排序"><a class="anchor" href="#89基数排序">#</a> 8.9 基数排序</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0L2EyYTg3Y2RkMDAxN2M1ZGI0YjAyNWE5ZGQ4YjM2M2U0LnBuZw==">image-20220922091544472</span></p><h3 id="810各种内部排序算法的比较"><a class="anchor" href="#810各种内部排序算法的比较">#</a> 8.10 各种内部排序算法的比较</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuL2ltZ19jb252ZXJ0LzgxNGYwNDNhZTRmMDA5YzE3NTEyMjg2OTg5ODZhNDZjLnBuZw==">image-20220922093415193</span></p><p>不稳定性：<mark>快些 (希) 选</mark>一<mark>堆</mark>好友来聊天</p><p>时间快：<mark>快些归队</mark></p><h3 id="811内部排序算法的应用"><a class="anchor" href="#811内部排序算法的应用">#</a> 8.11 内部排序算法的应用</h3><ol><li><p>若<mark> n 较小</mark>，可以采用<mark>选择排序或插入排序</mark>。当记录本身信息量较大时，使用选择排序较好。</p></li><li><p>若<mark>初始状态已基本有序</mark>，可以选用<mark>插入排序或冒泡排序</mark>。</p></li><li><p><mark>所需的辅助空间：堆排序 &lt; 快速排序 &lt; 归并排序</mark></p></li><li><p>交换次数最小的排序是简单选择排序</p></li><li><p>排序速度与数据的初始排列状态没有关系的是简单选择排序。</p></li></ol><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-05-24 20:44:35" itemprop="dateModified" datetime="2024-05-24T20:44:35+08:00">2024-05-24</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="REMU 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="REMU 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="REMU 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>REMU <i class="ic i-at"><em>@</em></i>REM</li><li class="link"><strong>本文链接：</strong> <a href="https://loveremu.github.io/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" title="数据结构(摘抄)">https://loveremu.github.io/2024/05/23/数据结构（摘抄）/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/05/23/%E8%AE%A1%E7%BD%91%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;10-min.png" title="计算机网络考研笔记(摘抄)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 408</span><h3>计算机网络考研笔记(摘抄)</h3></a></div><div class="item right"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;5d483b6823fbaa73b5391db5491fbb7a.jpg" title="数据结构考研笔记(摘抄)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 408</span><h3>数据结构考研笔记(摘抄)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 算法的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 数据结构的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 数据抽象和抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 描述数据结构和算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 算法分析的基本方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 线性表的定义及基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 线性表的顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 数据结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 线性表的链接存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">1. 数据结构定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2. 基本操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. 双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">1. 数据结构定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">2. 基本操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. 循环链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4. 静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">2. 数据结构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">3 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 栈和队列的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 栈和队列的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1. 栈的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2. 栈的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3. 共享栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4. 队列的顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">5. 循环队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 栈和队列的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1. 栈的链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. 队列的链式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3. 双端队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%A0%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 表达式计算（栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E9%80%92%E5%BD%92%E6%A0%88"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 递归（栈）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">4 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 数组的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. 对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. 三角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. 三对角矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 稀疏矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">5 树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#521%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 二叉树的定义及主要特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#522%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 二叉树的顺序存储和链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">1. 顺序存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">2. 链式存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#523%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">1. 先序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text">2. 中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.3.</span> <span class="toc-text">3. 后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.3.4.</span> <span class="toc-text">4. 层次遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#524-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9E%84%E9%80%A0"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">5.2.4 线索二叉树的基本概念和构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#531%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">1. 双亲表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">2. 孩子表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">3. 孩子兄弟表示法（左孩子，右兄弟）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#532%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 森林和二叉树的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#533%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">5.3.3 树和森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 树和二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#541%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1 二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%9F%A5%E6%89%BE"><span class="toc-number">1.5.4.1.1.</span> <span class="toc-text">1. 查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%8F%92%E5%85%A5"><span class="toc-number">1.5.4.1.2.</span> <span class="toc-text">2. 插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.4.1.3.</span> <span class="toc-text">3. 删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD"><span class="toc-number">1.5.4.1.4.</span> <span class="toc-text">4. 查找性能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#542-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5"><span class="toc-number">1.5.4.2.1.</span> <span class="toc-text">1. 插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#543%E5%93%88%E5%A4%AB%E6%9B%BChuffman%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3 哈夫曼 (Huffman) 树和哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">6 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 图的存储及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#621%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 邻接矩阵法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#622%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 邻接表表示法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#631%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1 深度优先搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#632%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2 广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 图的基本应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#641%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1 拓扑排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#642%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2 关键路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#643-%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">6.4.3 最小代价生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.4.3.1.</span> <span class="toc-text">1.Prim 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.4.3.2.</span> <span class="toc-text">2.Kruskal 算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#644%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">6.4.4 最短路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%90%9C%E7%B4%A2search"><span class="toc-number">1.7.</span> <span class="toc-text">7 搜索（Search）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E6%90%9C%E7%B4%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 搜索的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 顺序搜索法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%97%A0%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1. 无序表的顺序搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2. 有序表的顺序搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 二分搜索法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-b-%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 B - 树及其基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%8F%92%E5%85%A5"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1. 插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2. 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-b-%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">3. B - 树的特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E6%95%A3%E5%88%97hash%E8%A1%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 散列 (Hash) 表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">2. 线性探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%B9%B3%E6%96%B9%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">3. 平方散列法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95%E5%8F%8C%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">4. 再散列法（双散列法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BC%AA%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97%E6%B3%95"><span class="toc-number">1.7.5.5.</span> <span class="toc-text">5. 伪随机序列法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">1.7.5.6.</span> <span class="toc-text">6. 拉链法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 搜索算法的分析及应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%86%85%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">8 内排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 排序的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 冒泡排序 (bubble sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fshell-sort"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 希尔排序 (shell sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7 堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88%E4%B8%A4%E8%B7%AF%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.8 两路合并排序 (merge sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.9.</span> <span class="toc-text">8.9 基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#810%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.8.10.</span> <span class="toc-text">8.10 各种内部排序算法的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#811%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.11.</span> <span class="toc-text">8.11 内部排序算法的应用</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="操作系统考研笔记(摘抄)">操作系统考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="数据结构考研笔记(摘抄)">数据结构考研笔记(摘抄)</a></li><li class="active"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" rel="bookmark" title="数据结构(摘抄)">数据结构(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%BD%91%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机网络考研笔记(摘抄)">计算机网络考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机组成原理(摘抄)">计算机组成原理(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机组成原理考研笔记(摘抄)">计算机组成原理考研笔记(摘抄)</a></li><li><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%91%98%E6%8A%84)/" rel="bookmark" title="操作系统(摘抄)">操作系统(摘抄)</a></li><li><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E6%91%98%E6%8A%84)/" rel="bookmark" title="计算机网络(摘抄)">计算机网络(摘抄)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="REMU" data-src="/images/avatar.jpg"><p class="name" itemprop="name">REMU</p><div class="description" itemprop="description">LOVEREMU blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">32</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/05/23/%E8%AE%A1%E7%BD%91%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%91%98%E6%8A%84)/" title="操作系统(摘抄)">操作系统(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="分类于 语言基础">语言基础</a></div><span><a href="/2024/02/05/MySQL(%E6%91%98%E6%8A%84)/" title="MySQL(摘抄)">MySQL(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/05/29/phigrose%E7%9A%84%E7%AC%AC%E4%B8%80%E9%A6%96%E9%AD%94%E7%8E%8B%E6%9B%B2/" title="phigros第一首魔王曲">phigros第一首魔王曲</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="操作系统考研笔记(摘抄)">操作系统考研笔记(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E6%91%98%E6%8A%84)/" title="计算机网络(摘抄)">计算机网络(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86(%E6%91%98%E6%8A%84)/" title="计算机组成原理(摘抄)">计算机组成原理(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a></div><span><a href="/2023/07/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="搜索与图论">搜索与图论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 编程基础">编程基础</a></div><span><a href="/2023/06/06/JAVA-OOP/" title="JAVA-OOP">JAVA-OOP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/Springboot%E5%9F%BA%E7%A1%80/" title="Springboot基础">Springboot基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="计算机组成原理考研笔记(摘抄)">计算机组成原理考研笔记(摘抄)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">REMU @ REMU's blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/05/23/数据结构（摘抄）/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->