<!-- build time:Fri Nov 29 2024 23:02:00 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="REM" href="https://loveremu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="REM" href="https://loveremu.github.io/atom.xml"><link rel="alternate" type="application/json" title="REM" href="https://loveremu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://loveremu.github.io/2023/07/28/JAVA-PLUS/"><title>JAVA-PLUS - 语言基础 | REMU's blog = REM = レムは天下一品だ</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JAVA-PLUS</h1><div class="meta"><span class="item" title="创建时间：2023-07-28 12:02:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-07-28T12:02:13+08:00">2023-07-28</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">REMU's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://LOVEREMU.github.io/images/10-min.png"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/918b8a10ceb284507cd0734551e1adb4.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/2-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/04034f662a6365690992b3b18702e4bf.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/alipay.png"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/1c96818ab5347906b12d081223b0bf5d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 语言基础"><span itemprop="name">语言基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://loveremu.github.io/2023/07/28/JAVA-PLUS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="REMU"><meta itemprop="description" content="レムは天下一品だ, LOVEREMU blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="REM"></span><div class="body md" itemprop="articleBody"><h1 id="java-plus"><a class="anchor" href="#java-plus">#</a> JAVA-PLUS</h1><hr><h2 id="static"><a class="anchor" href="#static">#</a> static</h2><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><p>叫做<strong>静态</strong>，可以修饰成员变量，成员方法</p><h3 id="修饰成员变量"><a class="anchor" href="#修饰成员变量">#</a> 修饰成员变量</h3><ol><li><strong>调用</strong><ul><li>成员变量按有无 static 修饰分为两种：<ul><li>类变量 (有)：属于类，在计算机中只有一份，会被全部对象共享，即全部对象共享一个，所以通常用 <code>类名.类变量</code> (不推荐用 <code>对象.类变量</code> ) 来访问</li><li>实例变量 (无)：对象的变量，属于每个对象，即每个对象都有一个，所以只能用 <code>对象.类变量</code> 来访问</li></ul></li></ul></li><li><strong>使用场景</strong><ul><li>在开发中希望只有一份，并且希望共享 (访问修改)，则可以定义成类变量来记住<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"><span class="comment">//利用无参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">    user.num++;</span><br><span class="line">&#125;<span class="comment">//每当用户创建一个对象，num都会加一，num就是创建对象个数，也是所有对象共享的类变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="修饰成员方法"><a class="anchor" href="#修饰成员方法">#</a> 修饰成员方法</h3><ol><li><strong>调用</strong><ul><li>成员方法按有无 static 修饰分为两种：<ul><li>类方法 (有)：属于类，在计算机中只有一份，会被全部对象共享，即全部对象共享一个，所以通常用 <code>类名.类方法</code> (不推荐用 <code>对象.类方法</code> ) 来访问，main 方法也是类方法</li><li>实例变量 (无)：对象的方法，属于每个对象，即每个对象都有一个，所以只能用 <code>对象.类方法</code> 来访问</li></ul></li></ul></li><li><strong>使用场景</strong><ul><li>作为工具类，给开发人员共同使用，提供代码利用率，通过工具类类名来访问</li><li>问题：为什么要用类方法来做工具类而不用实例方法<ul><li>实例方法需要创建对象来调用，<strong>占内存</strong>，而类方法可以直接使用类名调用，无需创建对象</li></ul></li><li>可以将构造器私有，让工具类无法创建对象 <code>private 类名()</code> , 使得类方法更好地作为工具类</li></ul></li></ol><h3 id="注意事项"><a class="anchor" href="#注意事项">#</a> 注意事项</h3><ol><li>类方法中可以直接访问类的成员 (包括类对象和类方法)，不可以直接访问实例成员 (包括实例变量和实例方法)</li><li>实例方法既可以直接访问类的成员，也可以直接访问实例成员 (同上)</li><li>实例方法中可以出现 this 关键字，类方法中不可以出现 this 关键字 (因为 this 表示当前对象，而类方法引用时一般不用对象来调用，所以 this 无法指代对象)</li></ol><h3 id="代码块"><a class="anchor" href="#代码块">#</a> 代码块</h3><ol><li>静态代码块<ul><li><strong>格式</strong>：static {}</li><li><strong>特点</strong>：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次</li><li><strong>作用</strong>：完成初始化类，例如：对类变量的初始化赋值<br><img data-src="/img/JAVAP1.png" alt="1"></li></ul></li><li>实例代码块<ul><li><strong>格式</strong>：{}</li><li><strong>特点</strong>：每次创建对象时，执行实例代码块，并在构造器前执行</li><li><strong>作用</strong>：和构造器一样，用来初始化对象，例如：对实例变量进行初始化，减少构造器的代码量</li></ul></li></ol><h3 id="单例设计模式"><a class="anchor" href="#单例设计模式">#</a> 单例设计模式</h3><ul><li>问题：什么是设计模式？<ul><li>回答：一种问题的最优解叫设计模式，设计模式有 20 多种，对应软件开发中会遇到的问题</li></ul></li><li>问题：设计模式学什么？<ul><li>回答：1. 解决什么问题 2. 怎么写</li></ul></li></ul><ol><li><strong>单例设计模式解决的问题</strong>：确保一个类只有一个对象</li><li><strong>写法</strong>：<ol><li>把类的构造器私有</li><li>定义一个类变量记住类的一个对象</li><li>定义一个类方法，返回对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="comment">//用类方法的调用方法调用</span></span><br><span class="line">    <span class="comment">//通过A类获取对象都是同一个对象，这也就是单例设计模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>应用场景</strong>：任务管理器，获取运行时对象</li><li><strong>好处</strong>：在这些业务场景下用单例设计模式，可以避免浪费内存</li></ol><hr><h2 id="继承"><a class="anchor" href="#继承">#</a> 继承</h2><h3 id="定义-2"><a class="anchor" href="#定义-2">#</a> 定义</h3><p>通过关键字 <code>extends</code> 使得一个类和另一个类建立父子关系<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//A类称为父类(基类或超类)B类叫子类(派生类)</span></span><br></pre></td></tr></table></figure><p></p><h3 id="特点"><a class="anchor" href="#特点">#</a> 特点</h3><ol><li>子类能继承（可以直接使用）父类<strong>非私有</strong>成员 (包括对象和方法)</li><li>子类的对象创建是由子类父类共同完成的 (用子类和父类代码共同创建，即两个 “代码合并” 创建)</li><li>对于父类中私有的对象可以在父类中创建 <code>getter(),setter()</code> 方法，在子类中调用进行访问<br><img data-src="/img/JAVAP2.png" alt="2"><br>可以看出相当于把 people 类和 studen 类看成一个类，也就是 “合并”</li></ol><h3 id="好处"><a class="anchor" href="#好处">#</a> 好处</h3><ul><li>减少重复代码编写 (通过对部分子类的相同代码提取出来作为父类，然后进行继承)</li></ul><h3 id="注意事项-2"><a class="anchor" href="#注意事项-2">#</a> 注意事项</h3><ol><li><strong>权限修饰符</strong>：<ul><li><code>private</code> : 在本类中可以访问</li><li><code>缺省</code> ：在本类中，以及在同一个包下的其他类中可以访问</li><li><code>protected</code> : 在本类中，以及同一个包下其他类，和任意包下<strong>子类</strong>可以访问 (不是子类，就算创建子类对象也无法访问)</li><li><code>public</code> : 在任意包下的任意类里可以访问</li></ul></li><li><strong>单继承</strong><ul><li>定义：一个类只能继承一个父类，JAVA 不支持多继承，但是可以多层继承 (比如从父类的父类进行使用)</li></ul></li><li><strong>Object</strong><ul><li>所有类都 (直接或间接) 继承 <code>Object</code> 类，都是他的子类或者孙子类 (即后代类)，也就是 <code>Object</code> 是所有类的祖宗类</li></ul></li><li><strong>方法重写</strong><ul><li>定义：当父类中的某个方法不能满足子类需求，子类可以重写一个方法名称，参数列表，去覆盖父类的方法，这个就是重写 (重写后方法访问会遵循<strong>就近原则</strong>)</li><li>注意：<ol><li>子类重写方法时，访问权限必须大于等于父类方法权限 ( <code>public &gt; protected &gt; 缺省</code> )</li><li>重写方法返回值类型必须与被重写方法返回值类型一样 (或者范围更小)</li><li>私有方法静态方法不能被重写，如果重写会报错的</li><li>使用<strong> Override 注释</strong> 增强可读性，检查错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法重写</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methed</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//methed为要重写的方法名，如果名字拼写错误，Override会进行提醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>常见开发应用场景：子类重写 Object 类的 toString () 方法，以便返回对象的内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;student&#123;name = &quot;</span>+ name +<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">//原来的toString返回地址，现在返回这个内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>子类访问其他成员的特点</strong><ul><li>就近原则 (包括成员方法和成员变量)</li><li>可以通过关键字 <code>super,this</code> 访问其他成员</li></ul></li><li><strong>子类构造器</strong><ul><li>特点：子类所有构造器，都会先调用父类构造器 (如果父类只有有参构造器则要手写 super (参数) 来调用父类构造器，如果不执行父类构造器，子类构造器也无法执行)，再执行自己<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">F</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//默认存在的方法，所以才会先执行F构造器</span></span><br><span class="line">        <span class="comment">//可以手写super(参数)来调用父类有参构造器，以此对父类中私有对象进行赋值，可以省去调用getset方法来赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当创建一个Z类型的变量时，会先执行构造器F然后执行Z(包括有参和无参)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>this (...) 调用兄弟构造器</strong><br><img data-src="/img/JAVAP3.png" alt="2"><br>由于 <code>this(),super()</code> 都要出现在第一行，所以他们不能同时出现</li></ol><hr><h2 id="多态"><a class="anchor" href="#多态">#</a> 多态</h2><ol><li>认识多态<ul><li>多态是<strong>继承 / 实现</strong>情况下的一种表现，变现为：对象多态 (类似某个人拥有不同身份)，行为多态 (类似某种技能不同人的掌握程度不同)</li><li>代码表现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//编译看等式左边，运行看右边</span></span><br><span class="line"><span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//People既可以是学生对象又可以是老师对象，这就是对象多态</span></span><br><span class="line"></span><br><span class="line">P1.run();</span><br><span class="line">p2.run();<span class="comment">//p1p2运行速度不同，这就是行为多态</span></span><br></pre></td></tr></table></figure></li><li>前提：有<strong>继承 / 实现</strong>的关系；存在父类引用子类对象，存在方法重写</li><li>注意事项：多态是指对象行为的多态，JAVA 中的属性不谈多态 (也就是对象属性只看等式左边)</li></ul></li><li>使用多态的好处<ul><li>在多态形式下，右边的对象是<strong>解耦合</strong> (一个机器由多个零件对接组成，可以方便拆卸更新组装新的零件) 的更便于扩展和维护</li><li>定义方法是，使用父类类型的形参，可以接收一切子类对象，扩展性更强更便利</li><li>弊端：多态下不能使用子类独有功能 (原因就是编译过程编译看等式左边，运行看右边)</li></ul></li><li>多态下的类型转换问题<ul><li>自动类型转换： <code>父类 变量名 = new 子类()</code></li><li>强制类型转化： <code>子类 变量名 = (子类) 父类变量</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">P</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//自动</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> (Teacher)P;<span class="comment">//强转后可以使用子类独有功能,将原来的people转换为子类Teacher</span></span><br></pre></td></tr></table></figure></li><li>强制类型转换注意事项<ol><li>存在继承 / 实现关系在编译阶段不会报错</li><li>运行时如果真实类型与强转后 (等式右边) 不同，就会报错</li><li>强转前可以使用关键字<strong> instanceof</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p1;</span><br><span class="line">    s2.test();<span class="comment">//不报错可以使用独有功能</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> (Teacher) P1;</span><br><span class="line">    t2.teach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><hr><h2 id="final-关键字"><a class="anchor" href="#final-关键字">#</a> final 关键字</h2><ul><li><code>final</code> 关键字是最终的意思，可以修饰 (类，方法，变量)</li><li>修饰类：该类被称为最终类，特点是<strong>不能被继承了</strong>，一般修饰工具类</li><li>修饰方法：该方法被称为最终方法，特点是<strong>不能被重写了</strong></li><li>修饰变量：该变量<strong>只能被赋值一次</strong><ol><li>局部变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">a = <span class="number">13</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span><span class="comment">//常见用法</span></span><br></pre></td></tr></table></figure></li><li>成员 (类似全局) 变量：静态成员变量，实例成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;REMU&quot;</span>;</span><br><span class="line"><span class="comment">//不对变量赋值会报错</span></span><br><span class="line"><span class="comment">//这是常量，一般建议常量名称全部大写，多个单词下划线连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;LM&quot;</span>;</span><br><span class="line"><span class="comment">//这种用法没有意义，一般不用final修饰实例变量，因为每个对象是不一样的</span></span><br></pre></td></tr></table></figure></li></ol></li><li>注意事项<ol><li>final 修饰基本类型变量，变量存储的<strong>数据</strong>不能被改变</li><li>final 修饰引用类型的变量，变量存储的<strong>地址</strong>不变，但地址所指向的内容可以被改变<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;;</span><br><span class="line">arr = <span class="literal">null</span>;<span class="comment">//报错，地址不能改变</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">222</span>;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h2 id="常量"><a class="anchor" href="#常量">#</a> 常量</h2><ul><li>定义：使用了 <code>static,final</code> 修饰的成员变量被称为常量</li><li>作用：通常用于记录系统的配置信息</li><li>命名规范：常量名称全部大写，多个单词下划线连接</li><li>好处：代码可读性好，可维护性好，使用常量和使用字面量是一样的性能 (编译后常量会被 &quot;宏替换&quot;)</li></ul><hr><h2 id="抽象"><a class="anchor" href="#抽象">#</a> 抽象</h2><ul><li>认识抽象<ol><li>用关键字 <code>abstract</code> 修饰类和成员方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//抽象方法：必须abstract修饰，只有方法签名，不能有方法体</span></span><br><span class="line">    <span class="comment">//有抽象方法类一定要声明为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类除了可以有抽象方法，以及不能创建对象以外其他和普通类一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>类该有的成员 (成员变量、方法、构造器)，抽象类都可以有</li><li>特点：<strong>抽象类不能创建对象</strong>，仅作为一种特殊的父类，让子类继承并实现</li><li>一个类继承抽象类，必须重写完抽象类的全部方法，否则这个类也必须定义为抽象类 (不重写继承到的类都是抽象类)</li></ol></li><li>好处<ol><li>父类清楚每个子类都要做某种行为，但完成方法不同，便可以定义为抽象方法，让每个子类都进行重写</li><li>更好的支持多态</li></ol></li><li>应用场景<br><strong>模板设计方法设计模式</strong><ol><li>解决了什么问题<ul><li>解决方法中存在重复代码问题</li></ul></li><li>怎么写<ul><li><strong>模板方法</strong>：把相同代码放进去</li><li><strong>抽象方法</strong>：具体实现交给子类</li></ul></li><li>理解：类似于写作文，模板放入模板方法，具体其他的内容抽象为正文，具体类，具体实现</li></ol></li></ul><hr><h2 id="接口"><a class="anchor" href="#接口">#</a> 接口</h2><ol><li><strong>定义</strong>：JAVA 提供了一个关键字 interface，用这个关键字可以定义出一个特殊的结构：接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量(默认常量，所以要符合命名规范)</span></span><br><span class="line">    <span class="comment">//成员方法(默认抽象方法，所以也不能写方法体)</span></span><br><span class="line">    <span class="comment">//除了以上两个，其他东西都不能出现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：接口是用来被类 <code>implements</code> 来实现的，实现接口的类称为实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>,C &#123;</span><br><span class="line">    testb1()&#123;</span><br><span class="line">        <span class="comment">//重写完所有接口的全部抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    testc1()&#123;</span><br><span class="line">        <span class="comment">//重写完所有接口的全部抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>特点</strong>：<ol><li>无法创建对象，以及只能有成员变量和成员方法</li><li>一个类可以实现多个接口 (可以理解成干爹)，实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类</li></ol></li><li><strong>好处</strong><ol><li>弥补单继承类的不足，一个类可以同时实现多个接口</li><li>让程序面向接口编程，方便切换各种业务实现</li></ol></li></ol><hr><h2 id="抽象类与接口的区别"><a class="anchor" href="#抽象类与接口的区别">#</a> 抽象类与接口的区别</h2><p><strong>相同点</strong></p><p>都不能被实例化 ，接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><p><strong>不同点</strong></p><ul><li>抽象类中的抽象方法的修饰符只能为 public 或者 protected，默认为 public；接口中的方法默认使用 public 修饰</li><li>接口成员变量默认为 public static final，必须赋初值，不能被修改。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；</li><li>实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>接口强调特定功能的实现，而抽象类强调所属关系。</li><li>抽象类可以包含方法、构造方法，方法可以实现，但是构造方法不能用于实例化，主要用途是被子类调用。接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体</li></ul><hr><h2 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h2><ol><li>定义：一个类定义在另一个类的内部，这个类就是内部类</li><li>场景：当一个类的内部包含了一个完整的事物，且这个事物没必要单独设计时，就可以把这个事物设计为内部类</li><li>形式：<ol><li><strong>成员内部类</strong>：一个普通的类成员，类似我们学过的普通的成员变量，成员方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="comment">//外部类成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> age;</span><br><span class="line">            System.out.println(age);<span class="comment">//打印方法中的age</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.age);<span class="comment">//指定外部类对象,打印外部类age</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//可指定本类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//内部类定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//引用</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> new.Outer().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>静态内部类</strong>：有 static 修饰的内部类属于外部类自己持有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();<span class="comment">//与静态成员一样可以用外部类名访问</span></span><br></pre></td></tr></table></figure></li><li><strong>局部内部类</strong>：定义在执行体中的类 (没什么用处)</li><li><strong>匿名内部类</strong>：<ol><li>特殊的局部内部类，定义在执行体中，无需声明名字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数值)&#123;</span><br><span class="line">    类体(一般是方法重写);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;<span class="comment">//编译阶段把内部类编译成一个子类，然后立即创建一个子类对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵呜~&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>用于方便的创建一个子类对象</li><li>使用场景：通常作为一个参数传输给方法</li></ol></li></ol></li></ol><hr><h2 id="枚举"><a class="anchor" href="#枚举">#</a> 枚举</h2><ul><li>定义：枚举是一种特殊的类</li><li>格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    名称一，名称二......</span><br><span class="line">    其他成员...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//第一行必须是罗列枚举对象的名字</span></span><br><span class="line">    x,y,z;<span class="comment">//会编译成常量，每个常量记住的都是枚举类的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="comment">//get,set方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> A.x;<span class="comment">//a1 = x</span></span><br></pre></td></tr></table></figure></li><li>注意事项：<ul><li>枚举类的构造器都是私有的，因此枚举类无法对外创建对象</li><li>枚举类都是最终类，无法被继承</li><li>枚举类中从第二行开始可以定义其他各种成员</li><li>可以设计单例</li></ul></li><li>应用场景：用来表示一组信息，然后作为参数进行传输 (可以配合 switch 传入枚举类，将罗列的对象作为情况分类标准)</li></ul><hr><h2 id="正则表达式"><a class="anchor" href="#正则表达式">#</a> 正则表达式</h2><ol><li>定义：由特定字符构成，代表规则</li><li>作用：<ul><li>用来校验数据格式是否符合规则</li><li>在一段文本中查找满足要求的内容</li></ul></li><li>书写规则<br><img data-src="/img/JAVAP4.jpg" alt="2"><br><img data-src="/img/JAVAP15.jpg" alt="2"><ul><li>s.matches () 判断 s 是否符合括号内的正则表达式规则</li></ul></li></ol><hr><h2 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h2><ol><li>定义：程序出现的问题就是异常</li><li>体系<br><img data-src="/img/JAVAP5.png" alt="2"></li><li>try-catch 语句<ul><li>try 抓住异常，若有异常则 catch 打印出来</li></ul></li><li>throws<ul><li>将方法内部出现的异常抛出去交给调用者处理</li></ul></li><li>自定义异常类<ul><li>解决 JAVA 没有带的异常类</li></ul></li><li>异常处理</li><li>断言<ul><li>断言是一种调试方式，断言失败会抛出 assertioerror</li><li>断言只能在开发和测试中使用</li><li>可恢复的错误不能使用断言，应该直接抛出异常</li><li>使用 assert 关键字</li></ul></li></ol><hr><h2 id="io流"><a class="anchor" href="#io流">#</a> IO 流</h2><h3 id="file类"><a class="anchor" href="#file类">#</a> File 类</h3><ol><li>创建对象： <code>File f1 = new File(&quot;文件的路径&quot;)</code> (可以用 \ 或者 / 来进入文件（D:/reso 或 D:\reso），可以访问文件也可以创建新的文件)</li><li>路径：<ul><li>绝对路径：带盘符（从电脑的磁盘一路找寻到文件所在地址的路径）</li><li>相对路径：不带盘符（默认在工程下寻找文件，在模块中寻找的路径）</li><li>在工程上如果使用绝对路径的话拷贝到其他设备，工程存储的位置发生变化的话，会无法访问，一般都会使用相对路径</li></ul></li><li>常用方法：<img data-src="/img/JAVAP6.jpg" alt="2"></li><li>注意：File 类只能对文件 (文件或者文件夹)<strong> 本身</strong>进行操作，不能读写文件里面存储的数据</li></ol><h3 id="输入输出流"><a class="anchor" href="#输入输出流">#</a> 输入输出流</h3><ol><li>作用：用于读写数据的 (可以读写文件或网络中的数据)</li><li>分类：<img data-src="/img/JAVAP7.png" alt="2"><ol><li>字节输入流：将网络或磁盘文件中的数据以字节的形式读入内存</li><li>字节输出流：将内存中的文件以字节的形式写到网络或者磁盘中去</li><li>字符输入流：将网络或磁盘文件中的数据以字符的形式读入内存</li><li>字符输入流：将内存中的文件以字符的形式写到网络或者磁盘中去</li></ol></li><li>体系：<img data-src="/img/JAVAP8.png" alt="2"></li></ol><hr><h2 id="多线程"><a class="anchor" href="#多线程">#</a> 多线程</h2><ul><li>定义：线程 (Thread) 是一个程序内部的执行流程，多线程是指从软硬件上实现的多条流程的技术 (多条线程由 CPU 负责调度)</li><li>创建线程：<ol><li>将类声明为 Thread 的子类，此子类应覆盖 Thread 的 run 方法，然后可以分配和启动子类的实例<br><img data-src="/img/JAVAP9.png" alt="2"></li><li>声明一个实现 Runnab 了接口类，该类实现 run 方法然后可以分配类的实例，创建 Thread 时作为参数传递，然后启动<br><img data-src="/img/JAVAP10.png" alt="2"></li></ol></li><li>线程同步<ol><li>作用：解决线程安全问题，让多个线程先后依次访问共享资源</li><li>常见方案加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后才会自动解锁，其他线程才能访问<ul><li>同步代码块：<img data-src="/img/JAVAP11.png" alt="2"></li><li>同步方法：<img data-src="/img/JAVAP12.png" alt="2"></li><li>Lock 锁：Lock 是接口，不能实例化<br><img data-src="/img/JAVAP13.png" alt="2"></li></ul></li></ol></li><li>关于同步通信的函数<ol><li>wait():<ul><li>wait () 方法是在 Object 类中定义的，用于实现线程间的协作。在调用 wait () 之前，线程必须先获得对象的锁。调用 wait () 会导致当前线程释放锁，并进入等待状态，直到其他线程调用相同对象上的 notify () 或 notifyAll () 方法来唤醒它。</li><li>wait () 主要用于实现线程之间的同步和协作，通常在某个线程等待某个条件满足时使用。</li></ul></li><li>join():<ul><li>join () 方法是在 Thread 类中定义的。当一个线程调用另一个线程的 join () 方法时，它会等待被调用线程执行完毕。换句话说，调用线程会阻塞，直到被调用线程执行完毕。</li><li>join () 主要用于确保线程的顺序执行，通常用于等待一个线程完成后再执行下一个线程。</li></ul></li></ol></li></ul><hr><h2 id="网络通信"><a class="anchor" href="#网络通信">#</a> 网络通信</h2><ul><li>作用：让设备中的程序与其他设备进行交互</li><li>基本的通信架构<ul><li>CS 架构 (client 客户端 /sever 服务器)<ul><li>客户端：需要程序员开发并且需要用户下载</li><li>服务端：需要程序员开发</li></ul></li><li>BS 架构 (browser 浏览器 /sever 服务器)<ul><li>浏览器：不用程序员开发，用户要下载浏览器</li><li>服务端：需要程序员开发</li></ul></li></ul></li><li>三要素<ol><li>IP 地址：设备在网络中的地址，是分配给上网设备的唯一标志，<ul><li>有 IPV4 (32 位) 和 IPV6 (128 位) 两种形式</li><li>IP 域名</li><li>公网 IP：是可以连接互联网的 IP 地址</li><li>内网 IP：也叫局域网，只能在组织内部使用</li><li>127.0.0.1 与 localhost：代表本机 IP 只会寻找当前所在的主机</li><li>有关 IP 的常用方法<img data-src="/img/JAVAP14.png" alt="2"></li></ul></li><li>端口：应用程序在设备中唯一标识 (16 位的二进制)</li><li>协议：链接数据在网络传输中的规则</li></ol></li></ul><hr><h2 id="框架"><a class="anchor" href="#框架">#</a> 框架</h2><ul><li>类似于 C++ 中的 STL (细节不表)</li><li>具体在官方文档查询常用的框架</li><li>STL 文章<a href="https://loveremu.github.io/2023/05/28/C++STL%E5%9F%BA%E6%93%8D/"> STL</a></li></ul><hr><h2 id="泛型"><a class="anchor" href="#泛型">#</a> 泛型</h2><ul><li>定义：定义类，接口，方法时，同时声明了一个或多个类型变量 (如：&lt;E&gt;), 称为泛型类，泛型接口，泛型方法，统称为泛型</li><li>常见泛型类可查阅官方文档</li></ul><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-07-30 20:54:22" itemprop="dateModified" datetime="2024-07-30T20:54:22+08:00">2024-07-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="REMU 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="REMU 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="REMU 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>REMU <i class="ic i-at"><em>@</em></i>REM</li><li class="link"><strong>本文链接：</strong> <a href="https://loveremu.github.io/2023/07/28/JAVA-PLUS/" title="JAVA-PLUS">https://loveremu.github.io/2023/07/28/JAVA-PLUS/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/07/21/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;918b8a10ceb284507cd0734551e1adb4.jpg" title="数学知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 算法与数据结构</span><h3>数学知识</h3></a></div><div class="item right"><a href="/2024/02/05/MySQL(%E6%91%98%E6%8A%84)/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;bfaa5f3a4fb5c982eaeead045be3c4b7.jpg" title="MySQL(摘抄)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 语言基础</span><h3>MySQL(摘抄)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java-plus"><span class="toc-number">1.</span> <span class="toc-text">JAVA-PLUS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.1.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">修饰成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">修饰成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.1.5.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">单例设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">1.2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">final 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">抽象类与接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.9.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.10.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%B5%81"><span class="toc-number">1.13.</span> <span class="toc-text">IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file%E7%B1%BB"><span class="toc-number">1.13.1.</span> <span class="toc-text">File 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.13.2.</span> <span class="toc-text">输入输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.14.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.15.</span> <span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">1.16.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.17.</span> <span class="toc-text">泛型</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/05/28/C++STL%E5%9F%BA%E6%93%8D/" rel="bookmark" title="STL基操">STL基操</a></li><li><a href="/2023/05/28/markdown%E5%9F%BA%E6%93%8D/" rel="bookmark" title="markdown基操">markdown基操</a></li><li><a href="/2023/05/29/python/" rel="bookmark" title="python基操">python基操</a></li><li><a href="/2023/06/05/C++%E4%B8%ADsscanf,sprintf/" rel="bookmark" title="C++中字符之间的转换">C++中字符之间的转换</a></li><li><a href="/2023/06/13/JAVA/" rel="bookmark" title="JAVA">JAVA</a></li><li class="active"><a href="/2023/07/28/JAVA-PLUS/" rel="bookmark" title="JAVA-PLUS">JAVA-PLUS</a></li><li><a href="/2024/02/05/MySQL(%E6%91%98%E6%8A%84)/" rel="bookmark" title="MySQL(摘抄)">MySQL(摘抄)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="REMU" data-src="/images/avatar.jpg"><p class="name" itemprop="name">REMU</p><div class="description" itemprop="description">LOVEREMU blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">33</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/07/21/%E6%95%B0%E8%AE%BA/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/02/05/MySQL(%E6%91%98%E6%8A%84)/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="分类于 语言基础">语言基础</a></div><span><a href="/2023/06/13/JAVA/" title="JAVA">JAVA</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2024/03/28/xxxHOLIC/" title="四月一日灵异事件薄">四月一日灵异事件薄</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2024/06/29/%E6%96%A9%E8%B5%A4%E7%BA%A2%E8%B5%A4%E7%9E%B3/" title="斩赤红之瞳">斩赤红之瞳</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/05/31/phigros%E7%AC%AC%E4%BA%8C%E9%A6%96%E9%AD%94%E7%8E%8B%E6%9B%B2/" title="phigros第二首魔王曲">phigros第二首魔王曲</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="数据结构考研笔记(摘抄)">数据结构考研笔记(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/Linux%E5%9F%BA%E7%A1%80/" title="Linux基础">Linux基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a></div><span><a href="/2023/07/05/%E6%90%9C%E7%B4%A2%E4%B8%8E%E4%B8%8E%E5%9B%BE%E8%AE%BA/" title="搜索与图论">搜索与图论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%BB%84%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0(%E6%91%98%E6%8A%84)/" title="计算机组成原理考研笔记(摘抄)">计算机组成原理考研笔记(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/06/05/phigros%E7%AC%AC%E4%BA%94%E9%A6%96%E9%AD%94%E7%8E%8B%E6%9B%B2/" title="phigros第四首魔王曲(终章)">phigros第四首魔王曲(终章)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-images/" title="分类于 ACGN images">ACGN images</a></div><span><a href="/2023/05/22/REM-s-first-article/" title="REM&#39;s first article">REM's first article</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">REMU @ REMU's blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/07/28/JAVA-PLUS/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->