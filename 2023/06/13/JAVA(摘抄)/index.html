<!-- build time:Tue Oct 08 2024 10:14:47 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="REM" href="https://loveremu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="REM" href="https://loveremu.github.io/atom.xml"><link rel="alternate" type="application/json" title="REM" href="https://loveremu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="学习"><link rel="canonical" href="https://loveremu.github.io/2023/06/13/JAVA(%E6%91%98%E6%8A%84)/"><title>JAVA(摘抄) - 语言基础 | REMU's blog = REM = レムは天下一品だ</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JAVA(摘抄)</h1><div class="meta"><span class="item" title="创建时间：2023-06-13 11:02:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-06-13T11:02:13+08:00">2023-06-13</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">REMU's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://LOVEREMU.github.io/images/7b1bad530f9181fa283bd5b8711832aa.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/5-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/10-min.png"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/1-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/3-min.jpg"></li><li class="item" data-background-image="https://LOVEREMU.github.io/images/2-min.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 语言基础"><span itemprop="name">语言基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://loveremu.github.io/2023/06/13/JAVA(%E6%91%98%E6%8A%84)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="REMU"><meta itemprop="description" content="レムは天下一品だ, LOVEREMU blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="REM"></span><div class="body md" itemprop="articleBody"><p>[TOC]</p><h1 id="collectioniterator"><a class="anchor" href="#collectioniterator">#</a> Collection+Iterator</h1><h2 id="一collection集合"><a class="anchor" href="#一collection集合">#</a> 一・Collection 集合</h2><h3 id="11集合概述"><a class="anchor" href="#11集合概述">#</a> 1.1 集合概述</h3><p><strong>集合</strong>：集合是 java 中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而是对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h3 id="12集合框架"><a class="anchor" href="#12集合框架">#</a> 1.2 集合框架</h3><blockquote><p>集合按照其存储结构可以分为两大类，分别是单列集合 <code>java.util.Collection</code> 和双列集合 <code>java.util.Map</code> 。</p></blockquote><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是 <code>java.util.List</code> 和 <code>java.util.Set</code> 。<ul><li><code>List</code> ：特点是元素有序，元素可重复。 <code>List</code> 接口的主要实现类有 <code>java.util.ArrayList</code> 和 <code>java.util.LinkedList</code> 。</li><li><code>Set</code> ：特点是元素无序，而且不可重复。 <code>Set</code> 接口的主要实现类有 <code>java.util.HashSet</code> 和 <code>java.util.TreeSet</code> 。</li></ul></li></ul><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p><h3 id="13collection常用功能"><a class="anchor" href="#13collection常用功能">#</a> 1.3Collection 常用功能</h3><p>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合 (List 和 Set) 通用的一些方法，<strong>这些方法可用于操作所有的单列集合</strong>。方法如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>public boolean add(E e)</code></td><td>把给定的对象添加到当前集合中 。</td></tr><tr><td><code>public void clear()</code></td><td>清空集合中所有的元素。</td></tr><tr><td><code>public boolean remove(E e)</code></td><td>把给定的对象在当前集合中删除。</td></tr><tr><td><code>public boolean contains(E e)</code></td><td>判断当前集合中是否包含给定的对象。</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>判断当前集合是否为空。</td></tr><tr><td><code>public int size()</code></td><td>返回集合中元素的个数。</td></tr><tr><td><code>public Object[] toArray()</code></td><td>把集合中的元素，存储到数组中。</td></tr></tbody></table><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; a1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a1.add(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        a1.add(<span class="string">&quot;美滋滋&quot;</span>);</span><br><span class="line">        a1.add(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        System.out.println(<span class="string">&quot;hhh是否移除？&quot;</span> + a1.remove(<span class="string">&quot;hhh&quot;</span>));</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        System.out.println(<span class="string">&quot;hhh在集合里面吗？&quot;</span> + a1.contains(<span class="string">&quot;hhh&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;集合大小：&quot;</span> + a1.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;集合是否为空？&quot;</span> + a1.isEmpty());</span><br><span class="line"></span><br><span class="line">        Object[] objects = a1.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">        a1.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合是否为空？&quot;</span> + a1.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[小皮皮, 美滋滋, hhh]</span><br><span class="line">hhh是否移除？true</span><br><span class="line">[小皮皮, 美滋滋]</span><br><span class="line">hhh在集合里面吗？false</span><br><span class="line">集合大小：2</span><br><span class="line">集合是否为空？false</span><br><span class="line">小皮皮</span><br><span class="line">美滋滋</span><br><span class="line">集合是否为空？true</span><br></pre></td></tr></table></figure><p></p><h2 id="二-iterator迭代器"><a class="anchor" href="#二-iterator迭代器">#</a> 二. Iterator 迭代器</h2><h3 id="21iterator接口"><a class="anchor" href="#21iterator接口">#</a> 2.1Iterator 接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK 专门提供了一个接口 <code>java.util.Iterator</code> 。 <code>Iterator</code> 接口也是 Java 集合中的一员，但它与 <code>Collection</code> 、 <code>Map</code> 接口有所不同， <code>Collection</code> 接口与 <code>Map</code> 接口主要用于存储元素，而 <code>Iterator</code> 主要用于迭代访问（即遍历） <code>Collection</code> 中的元素，因此 <code>Iterator</code> 对象也被称为迭代器。</p><p>想要遍历 Collection 集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code> : 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p><strong>迭代</strong>：即 Collection 集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p><strong>Iterator 接口的常用方法如下：</strong></p><ul><li><code>public E next()</code> : 返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code> : 如果仍有元素可以迭代，则返回 true。</li></ul><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">//使用多态方式，创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        coll.add(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;美滋滋&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的 next 方法，将会发生 java.util.NoSuchElementException 没有集合元素的错误</p></blockquote><h3 id="22增加for"><a class="anchor" href="#22增加for">#</a> 2.2 增加 for</h3><p>增强 for 循环 (也称 for each 循环) 是<strong> JDK1.5</strong> 以后出来的一个高级 for 循环，专门用来遍历数组和集合的。<strong>它的内部原理其实是个 Iterator 迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</strong></p><p>格式：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><p><strong>练习 1：遍历数组</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">434</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>练习 2：遍历集合</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;美滋滋&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : c) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><blockquote><p>小贴士：</p><p>新 for 循环必须有被遍历的目标。目标只能是 Collection 或者是数组。新式 for 仅仅作为遍历操作出现。</p></blockquote><hr><h1 id="第一章-file类"><a class="anchor" href="#第一章-file类">#</a> 第一章 File 类</h1><h2 id="11-概述"><a class="anchor" href="#11-概述">#</a> 1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="12-构造方法"><a class="anchor" href="#12-构造方法">#</a> 1.2 构造方法</h2><ul><li><p><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File 实例。</p></li><li><p><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File 实例。</p></li><li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File 实例。</p></li><li><p>构造举例，代码如下：</p></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaIo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 文件路径名</span></span><br><span class="line">        File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image\\img1.png&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line">		<span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">        File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image&quot;</span>,<span class="string">&quot;img1.png&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line">		<span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">        File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image&quot;</span>);</span><br><span class="line">        File f4=<span class="keyword">new</span> <span class="title class_">File</span>(f3,<span class="string">&quot;img1.png&quot;</span>);</span><br><span class="line">        System.out.println(f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><ol><li>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</li></ol></blockquote><h2 id="13-常用方法"><a class="anchor" href="#13-常用方法">#</a> 1.3 常用方法</h2><h3 id="获取功能的方法"><a class="anchor" href="#获取功能的方法">#</a> 获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath()</code> ：返回此 File 的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此 File 转换为路径名字符串。</p></li><li><p><code>public String getName()</code> ：返回由此 File 表示的文件或目录的名称。</p></li><li><p><code>public long length()</code> ：返回由此 File 表示的文件的长度。</p><p>方法演示，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaIo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image\\img1.png&quot;</span>);</span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line">        File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;img1.png&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\sublime文件&quot;</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">D:\image\img1.png</span><br><span class="line">D:\image\img1.png</span><br><span class="line">img1.png</span><br><span class="line"><span class="number">164634</span></span><br><span class="line">D:\.metadata\img1.png</span><br><span class="line">img1.png</span><br><span class="line">img1.png</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p></p></li></ul><blockquote><p>API 中说明：length ()，表示文件的长度。但是 File 对象表示目录，则返回值未指定（为 0）。</p></blockquote><h3 id="判断功能的方法"><a class="anchor" href="#判断功能的方法">#</a> 判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此 File 表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此 File 表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此 File 表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaIo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image\\img1.png&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f1是否存在?&quot;</span>+f1.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;f1是否是目录?&quot;</span>+f1.isDirectory());</span><br><span class="line">        System.out.println(<span class="string">&quot;f1是否是文件？&quot;</span>+f1.isFile());</span><br><span class="line"></span><br><span class="line">        File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;img1.png&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f2是否存在?&quot;</span>+f2.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;f2是否是目录?&quot;</span>+f2.isDirectory());</span><br><span class="line">        System.out.println(<span class="string">&quot;f2是否是文件？&quot;</span>+f2.isFile());</span><br><span class="line"></span><br><span class="line">        File f3=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\image&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;f3是否存在?&quot;</span>+f3.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;f3是否是目录?&quot;</span>+f3.isDirectory());</span><br><span class="line">        System.out.println(<span class="string">&quot;f3是否是文件？&quot;</span>+f3.isFile());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">f1是否存在?<span class="literal">true</span></span><br><span class="line">f1是否是目录?<span class="literal">false</span></span><br><span class="line">f1是否是文件？<span class="literal">true</span></span><br><span class="line">f2是否存在?<span class="literal">false</span></span><br><span class="line">f2是否是目录?<span class="literal">false</span></span><br><span class="line">f2是否是文件？<span class="literal">false</span></span><br><span class="line">f13是否存在?<span class="literal">true</span></span><br><span class="line">f3是否是目录?<span class="literal">true</span></span><br><span class="line">f3是否是文件？<span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><h3 id="创建删除功能的方法"><a class="anchor" href="#创建删除功能的方法">#</a> 创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</li><li><code>public boolean delete()</code> ：删除由此 File 表示的文件或目录。</li><li><code>public boolean mkdir()</code> ：创建由此 File 表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此 File 表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>API 中说明：delete 方法，如果此 File 表示目录，则目录必须为空才能删</p></blockquote><h3 id="绝对路径和相对路径"><a class="anchor" href="#绝对路径和相对路径">#</a> 绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaIo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        File f1=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Java学习视频\\02-Java语言进阶\\day09_字节流、字符流\\day09【字节流、字符流】-笔记.pdf&quot;</span>);</span><br><span class="line">        File f2=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;day09【字节流、字符流】-笔记.pdf&quot;</span>);</span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\Java学习视频\<span class="number">02</span>-Java语言进阶\day09_字节流、字符流\day09【字节流、字符流】-笔记.pdf</span><br><span class="line">D:\.metadata\day09【字节流、字符流】-笔记.pdf</span><br></pre></td></tr></table></figure><p></p><h2 id="14-目录的遍历"><a class="anchor" href="#14-目录的遍历">#</a> 1.4 目录的遍历</h2><ul><li><p><code>public String[] list()</code> ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</p></li><li><p><code>public File[] listFiles()</code> ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</p></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaIo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\wxAppWork&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">        String[] list = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>调用 listFiles 方法的 File 对象，表示的必须是实际存在的目录，否则返回 null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a class="anchor" href="#第二章-递归">#</a> 第二章 递归</h1><h2 id="21-概述"><a class="anchor" href="#21-概述">#</a> 2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以 A 方法调用 B 方法，B 方法调用 C 方法，C 方法调用 A 方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法，禁止递归。</li></ul></li></ul><h2 id="22-递归累加求和"><a class="anchor" href="#22-递归累加求和">#</a> 2.2 递归累加求和</h2><h3 id="计算1-~-n的和"><a class="anchor" href="#计算1-~-n的和">#</a> 计算 1 ~ n 的和</h3><p><strong>分析</strong>：num 的累和 = num + (num-1) 的累和，所以可以把累和的操作定义成一个方法，递归调用。</p><p><strong>实现代码</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        System.out.println(getSum(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n+getSum(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p></blockquote><h2 id="23-递归求阶乘"><a class="anchor" href="#23-递归求阶乘">#</a> 2.3 递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure><p></p><p><strong>分析</strong>：这与累和类似，只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合 int 类型的范围。</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure><p></p><p><strong>代码实现</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        System.out.println(getMul(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMul</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n*getMul(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="24-递归打印多级目录"><a class="anchor" href="#24-递归打印多级目录">#</a> 2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        File dir=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Java学习视频\\day06_类与对象、封装、构造方法&quot;</span>);</span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名&quot;</span>+file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录&quot;</span>+file.getAbsolutePath());</span><br><span class="line">                <span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="第三章-综合案例"><a class="anchor" href="#第三章-综合案例">#</a> 第三章 综合案例</h1><h2 id="31-文件搜索"><a class="anchor" href="#31-文件搜索">#</a> 3.1 文件搜索</h2><p>搜索 <code>D:\aaa</code> 目录中的 <code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        File dir=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\Java学习视频\\day06_类与对象、封装、构造方法&quot;</span>);</span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;01-只有一个对象的内存图.png&quot;</span>))</span><br><span class="line">          	    System.out.println(file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="32-文件过滤器优化"><a class="anchor" href="#32-文件过滤器优化">#</a> 3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code> 是一个接口，是 File 的过滤器。 该接口的对象可以传递给 File 类的 <code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)</code> ：测试 pathname 是否应该包含在当前 File 目录中，符合则返回 true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code> 方法，参数为 File，表示当前 File 下所有的子文件和子目录。保留住则返回 true，过滤掉则返回 false。保留规则：<ol><li>要么是.java 文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用， <code>listFiles(FileFilter)</code> 返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiGuiDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir2</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">      	<span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.java&quot;</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p></p><h2 id="33-lambda优化"><a class="anchor" href="#33-lambda优化">#</a> 3.3 Lambda 优化</h2><p><strong>分析：</strong> <code>FileFilter</code> 是只有一个方法的接口，因此可以用 lambda 表达式简写。</p><p>lambda 格式：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>代码实现：</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDir3</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">  	<span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	<span class="keyword">return</span> f.getName().endsWith(<span class="string">&quot;.java&quot;</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h1 id="java-junit单元测试"><a class="anchor" href="#java-junit单元测试">#</a> Java---Junit 单元测试</h1><h2 id="1测试分类"><a class="anchor" href="#1测试分类">#</a> 1. 测试分类</h2><ul><li><strong>黑盒测试</strong>：不需要写代码，给输入值，看程序是否能够输出期望的值。</li><li><strong>白盒测试</strong>：需要写代码。关注程序具体的执行流程。</li></ul><h2 id="2junit使用白盒测试"><a class="anchor" href="#2junit使用白盒测试">#</a> 2.Junit 使用：白盒测试</h2><ol><li><p>定义一个测试类（测试用例）</p><p>建议：</p><ul><li>测试类名：被测试的类名 Test CalculatorTest</li><li>包名：xxx.xxx.xx.test cn.itcast.test</li></ul></li><li><p>定义测试方法（可以独立运行）</p><p>建议：</p><ul><li>方法名：test 测试的方法名 testAdd ()</li><li>返回值：void</li><li>参数列表：空参</li></ul></li><li><p>给方法加 <code>@Test</code></p></li><li><p>导入 <code>junit</code> 依赖环境</p></li><li><p>判定结果</p><ul><li>红色：失败</li><li>绿色：成功</li></ul><p>一般我们会使用断言操作来处理结果 <code>Assert.assertEquals(期望的结果,运算的结果);</code></p></li><li><p>补充</p><ul><li><strong><code>@Before</code> </strong>：修饰的方法会在测试方法之前被自动执行。</li><li><strong><code>@After</code> </strong>：修饰的方法会在测试方法之后被自动执行。</li></ul></li></ol><p><strong>代码演示</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalutorTest</span> &#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">1</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> s.add(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        TestCase.assertEquals(<span class="number">3</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">1</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">int</span> res=student.sub(a,b);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        TestCase.assertEquals(<span class="number">1</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">init...</span><br><span class="line"><span class="number">1</span></span><br><span class="line">close...</span><br></pre></td></tr></table></figure><p></p><hr><h1 id="java-stream流"><a class="anchor" href="#java-stream流">#</a> Java---Stream 流</h1><h2 id="1引言"><a class="anchor" href="#1引言">#</a> 1. 引言</h2><ul><li><p><strong>传统集合的多步遍历代码</strong></p><p>几乎所有的集合（如 <code>Collection</code> 接口或 <code>Map</code> 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元 素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。例如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ForEach</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">		alist.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>循环遍历的弊端</strong></p><p>Java 8 的 <code>Lambda</code> 让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li>for 循环的语法就是 “<strong>怎么做</strong>”</li><li>for 循环的循环体才是 “<strong>做什么</strong>”</li></ul><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从<strong>第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合 A 根据条件一过滤为子集 B；</li><li>然后再根据条件二过滤为子集 C。 那怎么办？在 Java 8 之前的做法可能为：</li></ol><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02NormalFilter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">		List&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">				zhangList.add(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; shortList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">				shortList.add(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String name : shortList) &#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码中含有三个循环，每一个作用不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字有三个字的人；</li><li>最后进行对结果进行打印输出。</li></ol><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</p><p>那， <code>Lambda</code> 的衍生物 <code>Stream</code> 能给我们带来怎样更加优雅的写法呢？</p></li><li><p><strong>Stream 的更优写法</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="2流式思想概述"><a class="anchor" href="#2流式思想概述">#</a> 2. 流式思想概述</h2><p>Stream（流）是一个来自数据源的元素队列 。</p><ul><li>元素是特定类型的对象，形成一个队列。 Java 中的 Stream 并不会存储元素，而是按需计算。</li><li><strong>数据源</strong>流的来源。 可以是集合，数组等。</li></ul><p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行 (laziness) 和短路 ( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过 Iterator 或者增强 for 的方式，显式的在集合外部进行迭代， 这叫做外部迭 代。 Stream 提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以 像链条一样排列，变成一个管道。</p><h2 id="3获取流"><a class="anchor" href="#3获取流">#</a> 3. 获取流</h2><p><code>java.util.stream.Stream</code> 是 Java 8 新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式</p><ul><li>所有的 <code>Collection</code> 集合都可以通过 <code>stream</code> 默认方法获取流；。</li><li><code>Stream</code> 接口的静态方法 <code>of</code> 可以获取数组对应的流。</li></ul><h3 id="31根据collection获取流"><a class="anchor" href="#31根据collection获取流">#</a> 3.1 根据 Collection 获取流</h3><p>首先， <code>java.util.Collection</code> 接口中加入了 <code>default</code> 方法 <code>stream</code> 用来获取流，所以其所有实现类均可获取流。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04GetStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">		Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">		Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="32根据map获取流"><a class="anchor" href="#32根据map获取流">#</a> 3.2 根据 Map 获取流</h3><p><code>java.util.Map</code> 接口不是 <code>Collection</code> 的子接口，且其 K-V 数据结构不符合流元素的单一特征，所以获取对应的流 需要分 <code>key</code> 、 <code>value</code> 或 <code>entry</code> 等情况。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05GetStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">		Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">		Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="33根据数组获取流"><a class="anchor" href="#33根据数组获取流">#</a> 3.3 根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <code>Stream</code> 接口中提供了静态方法 <code>of</code> ，使用很简单：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06GetStream</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] array = &#123; <span class="string">&quot;xpp&quot;</span>, <span class="string">&quot;mzz&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="string">&quot;lbj&quot;</span> &#125;;</span><br><span class="line">		Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h2 id="4常用方法"><a class="anchor" href="#4常用方法">#</a> 4. 常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的 API。这些方法可以被分成两种：</p><ul><li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持<strong>链式调用</strong>。（除了终结方法外，其余方法均为延迟方法。）</li><li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li></ul><h3 id="41逐一处理foreach"><a class="anchor" href="#41逐一处理foreach">#</a> 4.1 逐一处理：forEach</h3><p>虽然方法名字叫 <code>forEach</code> ，但是与 <code>for</code> 循环中的 “ <code>for-each</code> ” 昵称不同。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p></p><p><strong>复习 Consumer 接口</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法<span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure><p></p><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamForEach</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;小皮皮&quot;</span>, <span class="string">&quot;美滋滋&quot;</span>, <span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">		stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="42过滤filter"><a class="anchor" href="#42过滤filter">#</a> 4.2 过滤：filter</h3><p>可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个 <code>Lambda</code> 或方法引用）作为筛选条件。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p></p><p><strong>复习 Predicate 接口</strong></p><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure><p></p><p>该方法将会产生一个 <code>boolean</code> 值结果，代表指定的条件是否满足。如果结果为 <code>true</code> ，那么 <code>Stream</code> 流的 <code>filter</code> 方法 将会留用元素；如果结果为 <code>false</code> ，那么 <code>filter</code> 方法将会舍弃元素。</p><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07StreamFilter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;xpp&quot;</span>, <span class="string">&quot;mzz&quot;</span>, <span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;x&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="43映射map"><a class="anchor" href="#43映射map">#</a> 4.3 映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用 <code>map</code> 方法。方法签名：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p></p><p>该接口需要一个 <code>Function</code> 函数式接口参数，可以将当前流中的<strong> T</strong> 类型数据转换为另一种<strong> R</strong> 类型的流。</p><p><strong>复习 Function 接口</strong></p><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure><p></p><p>这可以将一种<strong> T</strong> 类型转换成为<strong> R</strong> 类型，而这种转换的动作，就称为 “映射”。</p><p><strong>基本使用</strong></p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo08StreamMap &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;);</span><br><span class="line">		Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="44统计个数count"><a class="anchor" href="#44统计个数count">#</a> 4.4 统计个数：count</h3><p>正如旧集合 <code>Collection</code> 当中的 <code>size</code> 方法一样，流提供 <code>count</code> 方法来数一数其中的元素个数：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p></p><p>该方法返回一个 <code>long</code> 值代表元素个数（不再像旧集合那样是 int 值）。</p><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09StreamCount</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;xpp&quot;</span>, <span class="string">&quot;mzz&quot;</span>, <span class="string">&quot;xhh&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">&quot;x&quot;</span>));</span><br><span class="line">		System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="45取用前几个limit"><a class="anchor" href="#45取用前几个limit">#</a> 4.5 取用前几个：limit</h3><p><code>limit</code> 方法可以对流进行截取，只取用前 n 个。方法签名：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure><p></p><p>参数是一个 <code>long</code> 型，如果集合当前长度大于参数则进行截取；否则不进行操作。</p><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamLimit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;小皮皮&quot;</span>, <span class="string">&quot;美滋滋&quot;</span>, <span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">		System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="46跳过前几个skip"><a class="anchor" href="#46跳过前几个skip">#</a> 4.6 跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span></span><br></pre></td></tr></table></figure><p></p><p>如果流的当前长度大于 n，则跳过前 n 个；否则将会得到一个长度为 0 的空流。</p><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamSkip</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;xp&quot;</span>, <span class="string">&quot;mz&quot;</span>, <span class="string">&quot;da&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">System.out.println(result.count()); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h3 id="47组合concat"><a class="anchor" href="#47组合concat">#</a> 4.7 组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code> 。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>备注：这是一个静态方法与 <code>java.lang.String</code> 当中的 <code>concat</code> 方法是不同的</p></blockquote><p><strong>基本使用</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;美滋滋&quot;</span>);</span><br><span class="line">		Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h1 id="常用api"><a class="anchor" href="#常用api">#</a> 常用 API</h1><h2 id="1object类"><a class="anchor" href="#1object类">#</a> 1.Object 类</h2><h3 id="11概述"><a class="anchor" href="#11概述">#</a> 1.1 概述</h3><p><code>java.lang.Object</code> 类是 Java 语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是 Object。</p><p>如果一个类没有特别指定父类，那么默认则继承自 Object 类。</p><h3 id="12tostring方法"><a class="anchor" href="#12tostring方法">#</a> 1.2toString 方法</h3><ol><li><p><strong>方法摘要</strong></p><ul><li><code>public String toString()</code> ：返回该对象的字符串表示。</li></ul><p>toString 方法返回该对象的字符串表示，其实该字符串内容就是对象的类型 +@+ 内存地址值。</p><p>由于 toString 方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，<strong>因此也需要重写它</strong>。</p></li><li><p><strong>覆盖重写</strong></p><p>如果不希望使用 toString 方法的默认行为，则可以对它进行覆盖重写。例如自定义的 Person 类：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候，其实通过该对象调用了其 toString () 方法。</p></blockquote></li></ol><h3 id="13equals方法"><a class="anchor" href="#13equals方法">#</a> 1.3equals 方法</h3><ol><li><p><strong>方法摘要</strong></p><p><code>public boolean equals(Object obj)</code> ：指示其他某个对象是否与此对象 “相等”。</p><p>调用成员方法 equals 并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的 “相同” 有默认和自定义两种方式。</p></li><li><p><strong>默认地址比较</strong></p><p>如果没有覆盖重写 equals 方法，那么 Object 类中默认进行 <code>==</code> 运算符的<strong>对象地址比较</strong>，只要不是同一个对象，结果必然为 false</p></li><li><p><strong>对象内容比较</strong></p><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写 equals 方法。例如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数 IDE 都可以自动生成 equals 方法的代码内容。在 IntelliJ IDEA 中，可以使用 <code>Code</code> 菜单中的 <code>Generate…</code> 选项，也可以使用快捷键 <code>alt+insert</code> ，并选择 <code>equals() and hashCode()</code> 进行自动代码生成。</p></li></ol><h3 id="14objects类"><a class="anchor" href="#14objects类">#</a> 1.4Objects 类</h3><p>在刚才 IDEA 自动重写 equals 代码中，使用到了 <code>java.util.Objects</code> 类，那么这个类是什么呢？</p><p>在<strong> JDK7</strong> 添加了一个 Objects 工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是 null-save（空指针安全的）或 null-tolerant（容忍空指针的），用于计算对象的 hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object 的 equals 方法容易抛出空指针异常，而 Objects 类中的 equals 方法就优化了这个问题。方法如下：</p><p><code>public static boolean equals(Object a, Object b)</code> ：判断两个对象是否相等。</p><p>源码：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="2日期时间类"><a class="anchor" href="#2日期时间类">#</a> 2. 日期时间类</h2><h3 id="21date类"><a class="anchor" href="#21date类">#</a> 2.1Date 类</h3><ol><li><p><strong>概述</strong></p><p><code>java.util.Date</code> 类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅 Date 类的描述，发现 Date 拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code> ：分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code> ：分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为 “历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为 1970 年 1 月 1 日 8 时 0 分 0 秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定 long 类型的构造参数，可以自定义毫秒时刻。例如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">564647687556L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Sat Jun <span class="number">26</span> <span class="number">20</span>:<span class="number">17</span>:<span class="number">46</span> CST <span class="number">2021</span></span><br><span class="line">Mon Nov <span class="number">23</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">47</span> CST <span class="number">1987</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>常用方法</strong></p><p>Date 类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul></li></ol><h3 id="22dateformat类"><a class="anchor" href="#22dateformat类">#</a> 2.2DateFormat 类</h3><ol><li><p><strong>概述</strong></p><p><code>java.text.DateFormat</code> 是日期 / 时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换，也就是可以在 Date 对象与 String 对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从 Date 对象转换为 String 对象。</li><li><strong>解析</strong>：按照指定的格式，从 String 对象转换为 Date 对象。</li></ul></li><li><p><strong>构造方法</strong></p><p><code>java.text.SimpleDateFormat</code> 。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code> ：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。</li></ul><p>参数 pattern 是一个字符串，代表日期时间的自定义格式。</p><p><strong>常用的格式规则为：</strong></p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02SimpleDateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>常用方法</strong></p><p>DateFormat 类的常用方法有：</p><ul><li><code>public String format(Date date)</code> ：将 Date 对象格式化为字符串。</li><li><code>public Date parse(String source)</code> ：将字符串解析为 Date 对象。</li></ul><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        DateFormat df=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> df.format(date);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> df.parse(res);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">26</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">33</span></span><br><span class="line">Sat Jun <span class="number">26</span> <span class="number">21</span>:<span class="number">10</span>:<span class="number">33</span> CST <span class="number">2021</span></span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="23calender类"><a class="anchor" href="#23calender类">#</a> 2.3Calender 类</h3><ol><li><p><strong>概述</strong></p><p><code>java.util.Calendar</code> 是日历类，在 Date 后出现，替换掉了许多 Date 的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p></li><li><p><strong>获取方式</strong></p><p>Calendar 为抽象类，由于语言敏感性，Calendar 类在创建对象时并非直接创建，而是<strong>通过静态方法创建，返回子类对象</strong>。</p><p>Calendar 静态方法</p><ul><li><code>public static Calendar getInstance()</code> ：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06CalendarInit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>常用方法</strong></p><p><strong>根据 Calendar 类的 API 文档，常用方法有：</strong></p><ul><li><code>public int get(int field)</code> ：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code> ：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code> ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code> ：返回一个表示此 Calendar 时间值（从历元到现在的毫秒偏移量）的 Date 对象。</li></ul><p><strong>Calendar 类中提供很多成员常量，代表给定的日历字段：</strong></p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从 0 开始，可以 + 1 使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12 小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24 小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为 1，可以 - 1 使用）</td></tr></tbody></table><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayofMonth</span> <span class="operator">=</span> c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayofMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2022</span>);</span><br><span class="line">        year = c.get(Calendar.YEAR);</span><br><span class="line">        </span><br><span class="line">        c.add(Calendar.MONTH, <span class="number">1</span>);</span><br><span class="line">        month = c.get(Calendar.MONTH);</span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayofMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> c.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">2021年5月27日</span></span><br><span class="line"><span class="comment">2022年6月27日</span></span><br><span class="line"><span class="comment">Wed Jul 27 10:12:26 CST 2022</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>西方星期的开始为周日，中国为周一。</p><p>在 Calendar 类中，月份的表示是以 0-11 代表 1-12 月。</p><p>日期是有大小关系的，时间靠后，时间越大。</p></blockquote></li></ol><h2 id="3system类"><a class="anchor" href="#3system类">#</a> 3.System 类</h2><p><code>java.lang.System</code> 类中提供了大量的<strong>静态方法</strong>，可以获取与系统相关的信息或系统级操作，在 System 类的 API 文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code> ：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> ：将数组中指定的数据拷贝到另一个数组中。</li></ul><h3 id="31currenttimemillis方法"><a class="anchor" href="#31currenttimemillis方法">#</a> 3.1currentTimeMillis 方法</h3><p>实际上，currentTimeMillis 方法就是 获取当前系统时间与 1970 年 01 月 01 日 00:00 点之间的毫秒差值。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="32arraycopy方法"><a class="anchor" href="#32arraycopy方法">#</a> 3.2arraycopy 方法</h3><p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> ：将数组中指定的数据拷贝到另一个数组中。</p><p>的拷贝动作是系统级的，性能很高。System.arraycopy 方法具有 5 个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><p><strong>练习</strong></p><p>将 src 数组中前 3 个元素，复制到 dest 数组的前 3 个位置上复制元素前：src 数组元素 [1,2,3,4,5]，dest 数组元素 [6,7,8,9,10]。复制元素后：src 数组元素 [1,2,3,4,5]，dest 数组元素 [1,2,3,9,10]</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">int</span>[] src=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dest=&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dest) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="4stringbuilder类"><a class="anchor" href="#4stringbuilder类">#</a> 4.StringBuilder 类</h2><h3 id="41-字符串拼接问题"><a class="anchor" href="#41-字符串拼接问题">#</a> 4.1 字符串拼接问题</h3><p>由于 String 类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在 API 中对 String 类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即 <code>&quot;Hello&quot;</code> 、 <code>&quot;World&quot;</code> 和 <code>&quot;HelloWorld&quot;</code> 。引用变量 s 首先指向 <code>Hello</code> 对象，最终指向拼接出来的新字符串对象，即 <code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的 String 对象，既耗时，又浪费空间。为了解决这一问题，可以使用 <code>java.lang.StringBuilder</code> 类。</p><h3 id="42stringbuilder概述"><a class="anchor" href="#42stringbuilder概述">#</a> 4.2StringBuilder 概述</h3><p>查阅 <code>java.lang.StringBuilder</code> 的 API，StringBuilder 又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来 StringBuilder 是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder 会自动维护数组的扩容。</p><h3 id="43构造方法"><a class="anchor" href="#43构造方法">#</a> 4.3 构造方法</h3><p>根据 StringBuilder 的 API 文档，常用构造方法有 2 个：</p><ul><li><code>public StringBuilder()</code> ：构造一个空的 StringBuilder 容器。</li><li><code>public StringBuilder(String str)</code> ：构造一个 StringBuilder 容器，并将字符串添加进去。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="44常用方法"><a class="anchor" href="#44常用方法">#</a> 4.4 常用方法</h3><p>StringBuilder 常用的方法有 2 个：</p><ul><li><code>public StringBuilder append(...)</code> ：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code> ：将当前 StringBuilder 对象转换为 String 对象。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        StringBuilder s2=s1.append(<span class="string">&quot;小皮皮美滋滋&quot;</span>);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s2.equals(s1));</span><br><span class="line">		<span class="comment">// 可以添加 任何类型</span></span><br><span class="line">        s1.append(<span class="literal">true</span>);</span><br><span class="line">        s1.append(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        s1.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(s1.toString());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1.toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">小皮皮美滋滋true100helloworld</span><br><span class="line">小皮皮美滋滋true100helloworld</span><br></pre></td></tr></table></figure><p></p><blockquote><p>备注：StringBuilder 已经覆盖重写了 Object 当中的 toString 方法。</p></blockquote><h2 id="5包装类"><a class="anchor" href="#5包装类">#</a> 5. 包装类</h2><h3 id="51概述"><a class="anchor" href="#51概述">#</a> 5.1 概述</h3><p>Java 提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于 java.lang 包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="52装箱与拆箱"><a class="anchor" href="#52装箱与拆箱">#</a> 5.2 装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为” 装箱 “与” 拆箱 “：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用 Integer 与 int 为例：</p><ul><li><p>基本数值 ----&gt; 包装对象</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iii</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>包装对象 ----&gt; 基本数值</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure><p></p></li></ul><h3 id="53自动装箱与自动拆箱"><a class="anchor" href="#53自动装箱与自动拆箱">#</a> 5.3 自动装箱与自动拆箱</h3><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5,加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        Integer i=<span class="number">2</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> i.getClass().toString();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        i=i+<span class="number">5</span>;</span><br><span class="line">        System.out.println(i.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">class java.lang.Integer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><h3 id="54基本类型与字符串之间的转换"><a class="anchor" href="#54基本类型与字符串之间的转换">#</a> 5.4 基本类型与字符串之间的转换</h3><ul><li><p><strong>基本类型转换为 String</strong></p><ul><li><code>num + &quot;&quot;</code></li><li><code>Integer.toString(num)</code></li><li><code>String.valueOf(num)</code></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">34</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">232</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Integer.toString(num);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">232</span></span><br><span class="line"><span class="comment">232</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>String 转换为基本类型</strong></p><p>除了 Character 类之外，其他所有包装类都具有 parseXxx 静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code> ：将字符串参数转换为对应的 byte 基本类型。</li><li><code>public static short parseShort(String s)</code> ：将字符串参数转换为对应的 short 基本类型。</li><li><code>public static int parseInt(String s)</code> ：将字符串参数转换为对应的 int 基本类型。</li><li><code>public static long parseLong(String s)</code> ：将字符串参数转换为对应的 long 基本类型。</li><li><code>public static float parseFloat(String s)</code> ：将字符串参数转换为对应的 float 基本类型。</li><li><code>public static double parseDouble(String s)</code> ：将字符串参数转换为对应的 double 基本类型。</li><li><code>public static boolean parseBoolean(String s)</code> ：将字符串参数转换为对应的 boolean 基本类型。</li></ul><p><strong>代码演示</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo18WrapperParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>注意：如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出 <code>java.lang.NumberFormatException</code> 异常。</p></blockquote></li></ul><h2 id="6math类"><a class="anchor" href="#6math类">#</a> 6.Math 类</h2><ol><li><p><strong>Math 类概述</strong></p><ul><li><code>Math</code> 执行基本数组运算的方法。</li></ul></li><li><p><strong>Math 中方法的调用方式</strong></p><ul><li><code>Math</code> 类中无构造方法，但内部的方法都是静态的，则可以通过 <code>类名.方法</code> 进行调用。</li></ul></li><li><p><strong>Math 类的常用方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>public static int abs(int a)</code></td><td>返回参数的绝对值</td></tr><tr><td><code>public static double ceil(double a)</code></td><td>返回大于或等于参数的最小 <code>double</code> 值，等于一个整数</td></tr><tr><td><code>public static double ceil(double a)</code></td><td>返回小于或等于参数的最大 <code>double</code> 值，等于一个整数</td></tr><tr><td><code>public static int round(float a)</code></td><td>按照四舍五入返回最接近参数的 <code>int</code></td></tr><tr><td><code>public static int max(int a,int b)</code></td><td>返回两个 <code>int</code> 值中的较大值</td></tr><tr><td><code>public static int max(int a,int b)</code></td><td>返回两个 <code>int</code> 值中的较小值</td></tr><tr><td><code>public static double pow (double a,double b)</code></td><td>返回 <code>a</code> 的 <code>b</code> 次幂的值</td></tr><tr><td><code>public static double random()</code></td><td>返回值为 <code>double</code> 的正值， <code>[0.0,1.0]</code></td></tr></tbody></table></li></ol><h2 id="7arrays类"><a class="anchor" href="#7arrays类">#</a> 7.Arrays 类</h2><blockquote><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p></blockquote><p>具有以下功能：</p><ul><li>给数组赋值：通过 <code>fill</code> 方法。</li><li>对数组排序：通过 <code>sort</code> 方法，按升序。</li><li>比较数组：通过 <code>equals</code> 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 <code>binarySearch</code> 方法能对排序好的数组进行二分查找法操作。</li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法和说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象 (Byte,Int,double 等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int 等）。</td></tr></tbody></table><hr><h1 id="java-反射"><a class="anchor" href="#java-反射">#</a> Java--- 反射</h1><h2 id="1反射概述"><a class="anchor" href="#1反射概述">#</a> 1. 反射概述</h2><p>将类的各个组成部分封装为其他对象，这就是反射机制。</p><p>好处：</p><ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol><h2 id="2获取class对象的方式"><a class="anchor" href="#2获取class对象的方式">#</a> 2. 获取 Class 对象的方式</h2><ol><li><code>Class.forName(&quot;全类名&quot;)</code> ：将字节码文件加载进内存，返回 Class 对象。<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</li></ul></li><li><code>类名.class</code> ：通过类名的属性 <code>class</code> 获取。<ul><li>多用于参数的传递。</li></ul></li><li><code>对象.getClass()</code> ： <code>getClass()</code> 方法在 <code>Object</code> 类中定义着。<ul><li>多用于对象的获取字节码的方式。</li></ul></li></ol><p><strong>代码演示</strong>：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;Main.Student&quot;</span>);</span><br><span class="line">        Class&lt;Student&gt; c2 = Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; c3 = student.getClass();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">        System.out.println(c3 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>.Student</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>.Student</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>.Student</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><p><strong>结论</strong>：同一个字节码文件 (*.class) 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个。</p><h2 id="3class对象功能"><a class="anchor" href="#3class对象功能">#</a> 3.Class 对象功能</h2><h3 id="31获取功能"><a class="anchor" href="#31获取功能">#</a> 3.1 获取功能</h3><ol><li><p><strong>获取成员变量们</strong></p><ul><li><code>Field[] getFields()</code> ：取指定名称的 <code>public</code> 修饰的成员变量。</li><li><code>Field getField(String name)</code> ：获取指定名称的 <code>public</code> 修饰的成员变量。</li><li><code>Field[] getDeclaredFields()</code> ：获取所有的成员变量，不考虑修饰符。</li><li><code>Field getDeclaredField(String name)</code></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;Student&gt; c = Student.class;</span><br><span class="line"></span><br><span class="line">        Field[] f1 = c.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : f1) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> c.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f2.get(s);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        f2.set(s, <span class="number">12</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        Field[] f3 = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : f3) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f4</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(f4);</span><br><span class="line">        <span class="comment">//忽略访问权限修饰符的安全检查</span></span><br><span class="line">        f4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> f4.get(s);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line">        f4.set(s, <span class="number">14</span>);</span><br><span class="line">        System.out.println(f4.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Main.Student.a</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Main.Student.a</span><br><span class="line"><span class="number">0</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>, a=<span class="number">12</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">private</span> java.lang.String Main.Student.name</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Main.Student.age</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> Main.Student.a</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> Main.Student.b</span><br><span class="line"><span class="type">int</span> Main.Student.c</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Main.Student.d</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Main.Student.d</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>获取构造方法们</strong></p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code></li><li><code>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;Student&gt; c = Student.class;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; c1 = c.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj</span> <span class="operator">=</span> c1.newInstance(<span class="string">&quot;xpp&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">        Constructor&lt;Student&gt; c2 = c.getConstructor();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj1</span> <span class="operator">=</span> c2.newInstance();</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">obj2</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">public</span> Main.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line">Student&#123;name=<span class="string">&#x27;xpp&#x27;</span>, age=<span class="number">23</span>, a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0</span>&#125;</span><br><span class="line">--------------------</span><br><span class="line"><span class="keyword">public</span> Main.Student()</span><br><span class="line">Student&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>, a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>, a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>获取成员方法们</strong></p><ul><li><code>Method[] getMethods()</code></li><li><code>Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li><li><code>Method[] getDeclaredMethods()</code></li><li><code>Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li></ul></li><li><p><strong>获取全类名</strong></p><ul><li><code>String getName()</code></li></ul></li></ol><hr><h1 id="java反射随笔"><a class="anchor" href="#java反射随笔">#</a> Java 反射随笔✌</h1><h2 id="1反射基础"><a class="anchor" href="#1反射基础">#</a> 1. 反射基础</h2><p><mark>Java 反射机制</mark>是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意一个对象，都能够知道它的任意属性和方法，这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>Java 反射机制主要提供以下这几个功能：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><h3 id="11class类"><a class="anchor" href="#11class类">#</a> 1.1Class 类</h3><p><mark>Class 类</mark>，Class 类也是一个实实在在的类，存在于 JDK 的 java.lang 包中。Class 类的实例表示 java 应用运行时的类 (class ans enum) 或接口 (interface and annotation)（每个 java 类运行时都在 JVM 里表现为一个 class 对象，可通过 <code>类名.class</code> 、 <code>类型.getClass()</code> 、 <code>Class.forName(&quot;类名&quot;)</code> 等方法获取 class 对象）。数组同样也被映射为为 class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型 boolean，byte，char，short，int，long，float，double 和关键字 void 同样表现为 class 对象。</p><p>到这我们也就可以得出以下几点信息：</p><ul><li>Class 类也是类的一种，与 class 关键字是不一样的。</li><li>手动编写的类被编译后会产生一个 Class 对象，其表示的是创建的类的类型信息，而且这个 Class 对象保存在同名.class 的文件中 (字节码文件)。</li><li>每个通过关键字 class 标识的类，在内存中有且只有一个与之对应的 Class 对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个 Class 对象。</li><li>Class 类只存私有构造函数，因此对应 Class 对象只能有 JVM 创建和加载。</li><li>Class 类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要 (关于反射稍后分析)。</li></ul><h3 id="12类加载"><a class="anchor" href="#12类加载">#</a> 1.2 类加载</h3><ol><li><p>类加载机制流程</p><p><img data-src="https://www.pdai.tech/_images/jvm/java_jvm_classload_2.png" alt="img"></p></li><li><p>类的加载</p><p><img data-src="https://www.pdai.tech/_images/java/java-basic-reflection-3.png" alt="img"></p></li></ol><blockquote><p>注：详细的类加载内容，看 JVM 板块。</p></blockquote><h2 id="2反射的使用"><a class="anchor" href="#2反射的使用">#</a> 2. 反射的使用</h2><h3 id="21class对象的获取"><a class="anchor" href="#21class对象的获取">#</a> 2.1Class 对象的获取</h3><p>在类加载的时候，jvm 会创建一个 class 对象。class 对象可以说是反射中最常见的。</p><blockquote><p>获取 class 对象的方式的主要三种：</p></blockquote><ul><li>根据类名：<mark>类名.class</mark></li><li>根据对象：<mark>对象.getClass ()</mark></li><li>根据全限定类名：<mark>Class.forName (全限定类名)</mark></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1Main1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Class对象的三种对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;根据类名：\t&quot;</span> + User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;根据对象：\t&quot;</span> + <span class="keyword">new</span> <span class="title class_">User</span>().getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;根据全限定类名：\t&quot;</span> + Class.forName(<span class="string">&quot;demo1.User&quot;</span>));</span><br><span class="line">        <span class="comment">//常用的方法</span></span><br><span class="line">        Class&lt;User&gt; userClass = User.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取全限定类名：\t&quot;</span> + userClass.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类名：\t&quot;</span> + userClass.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;实例化：\t&quot;</span> + userClass.newInstance());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据类名：	<span class="keyword">class</span> <span class="title class_">demo1</span>.User</span><br><span class="line">根据对象：	<span class="keyword">class</span> <span class="title class_">demo1</span>.User</span><br><span class="line">根据全限定类名：	<span class="keyword">class</span> <span class="title class_">demo1</span>.User</span><br><span class="line">获取全限定类名：	demo1.User</span><br><span class="line">获取类名：	User</span><br><span class="line">实例化：	User&#123;name=<span class="string">&#x27;init&#x27;</span>, age=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>再来看看 Class 类的方法：</p></blockquote><ul><li><p><code>toString()</code></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (isInterface() ? <span class="string">&quot;interface &quot;</span> : (isPrimitive() ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;class &quot;</span>))</span><br><span class="line">        + getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>toString () 方法能够将对象转换为字符串，toString () 首先判断 Class 类型是否是接口类型，也就是说普通类和接口都能用 Class 对象表示，然后在判断是否是基本数据类型，这里判断的都是基本数据类型和包装类，还有 void 类型。</p></li><li><p><code>getName()</code></p><p>获取类的全限定名称。（包括包名）即类的完整名称。</p><ul><li>如果是引用类型。比如 String.class.getName ()→ <code>java.lang.String</code></li><li>如果是基本数据类型。比如 byte.class.getName ()→ <code>byte</code></li><li>如果是数组类型。比如 new Object [3].getClass ().getName ()→ <code>[Ljava.lang.Object;</code></li></ul></li><li><p><code>getSimpleName()</code></p><p>获取类名（不包括包名）。</p></li><li><p><code>getCanonicalName()</code></p><p>获取全限定的类名 (包括包名)。</p></li><li><p><code>toGenericString()</code></p><p>返回类的全限定名称，而且包括类的修饰符和类型参数信息。</p></li><li><p><code>forName()</code></p><p>根据类名获得一个 Class 对象的引用，这个方法会使类对象进行初始化。</p><p>例如： <code>Class t = Class.forName(&quot;java.lang.Thread&quot;)</code> 就能够初始化一个 Thread 线程对象。</p><p>在 Java 中，一共有三种获取类实例的方式：</p><ul><li><code>Class.forName(java.lang.Thread)</code></li><li><code>Thread.class</code></li><li><code>thread.getClass()</code></li></ul></li><li><p><code>newInstance()</code><br>创建一个类的实例，代表着这个类的对象。上面 forName () 方法对类进行初始化，newInstance 方法对类进行实例化。使用该方法创建的类，必须带有无参的构造器。</p></li><li><p><code>getClassLoader()</code></p><p>获取类加载器对象。</p></li><li><p><code>getInterfaces()</code></p><p>获取当前类实现的类或是接口，可能是多个，所以返回的是 Class 数组。</p></li><li><p><code>isInterface()</code></p><p>判断 Class 对象是否是表示一个接口。</p></li><li><p><code>getFields()</code></p><p>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有 <code>getMethods</code> 和 <code>getConstructors</code> 。</p></li><li><p><code>getDeclaredFields</code></p><p>获得某个类的自己声明的字段，即包括 public、private 和 proteced，默认但是不包括父类声明的任何字段。类似的还有 <code>getDeclaredMethods</code> 和 <code>getDeclaredConstructors</code> 。</p></li></ul><blockquote><p>getName、getCanonicalName 与 getSimpleName 的区别：</p></blockquote><ul><li><code>getSimpleName</code> ：只获取类名.</li><li><code>getName</code> ：类的全限定名，jvm 中 Class 的表示，可以用于动态加载 Class 对象，例如 Class.forName。</li><li><code>getCanonicalName</code> ：返回更容易理解的表示，主要用于输出（toString）或 log 打印，大多数情况下和 getName 一样，但是在内部类、数组等类型的表示形式就不同了。</li></ul><p>栗子：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cry;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//普通类</span></span><br><span class="line">        System.out.println(Test.class.getSimpleName()); <span class="comment">//Test</span></span><br><span class="line">        System.out.println(Test.class.getName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        System.out.println(Test.class.getCanonicalName()); <span class="comment">//com.cry.Test</span></span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        System.out.println(inner.class.getSimpleName()); <span class="comment">//inner</span></span><br><span class="line">        System.out.println(inner.class.getName()); <span class="comment">//com.cry.Test$inner</span></span><br><span class="line">        System.out.println(inner.class.getCanonicalName()); <span class="comment">//com.cry.Test.inner</span></span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        System.out.println(args.getClass().getSimpleName()); <span class="comment">//String[]</span></span><br><span class="line">        System.out.println(args.getClass().getName()); <span class="comment">//[Ljava.lang.String;</span></span><br><span class="line">        System.out.println(args.getClass().getCanonicalName()); <span class="comment">//java.lang.String[]</span></span><br><span class="line">        <span class="comment">//我们不能用getCanonicalName去加载类对象，必须用getName</span></span><br><span class="line">        <span class="comment">//Class.forName(inner.class.getCanonicalName()); 报错</span></span><br><span class="line">        Class.forName(inner.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="22constructor类及其用法"><a class="anchor" href="#22constructor类及其用法">#</a> 2.2Constructor 类及其用法</h3><blockquote><p>Constructor 类存在于反射包 (java.lang.reflect) 中，反映的是 Class 对象所表示的类的构造方法。</p></blockquote><p><strong>获取 Constructor 对象是通过 Class 类中的方法获取的</strong>，Class 类与 Constructor 相关的主要方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;... parameterTypes)</td><td>返回指定参数类型、具有 public 访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有 public 访问权限的构造函数的 Constructor 对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</td><td>返回指定参数类型、所有声明的（包括 private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括 private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p>栗子：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructionTest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        clazz = Class.forName(<span class="string">&quot;com.example.javabase.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs1</span> <span class="operator">=</span>clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">&quot;hiway&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1:&quot;</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">&quot;hiway2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2:&quot;</span>+user2.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有构造包含private</span></span><br><span class="line">        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 查看每个构造方法需要的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取构造函数参数类型</span></span><br><span class="line">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造函数[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>+cons[i].toString() );</span><br><span class="line">            System.out.print(<span class="string">&quot;参数类型[&quot;</span>+i+<span class="string">&quot;]:(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</span><br><span class="line">                    System.out.print(clazzs[j].getName());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.print(clazzs[j].getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">User&#123;age=<span class="number">20</span>, name=<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">user1:User&#123;age=<span class="number">22</span>, name=<span class="string">&#x27;hiway&#x27;</span>&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">user2:User&#123;age=<span class="number">25</span>, name=<span class="string">&#x27;hiway2&#x27;</span>&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line">构造函数[<span class="number">0</span>]:<span class="keyword">private</span> com.example.javabase.User(<span class="type">int</span>,java.lang.String)</span><br><span class="line">参数类型[<span class="number">0</span>]:(<span class="type">int</span>,java.lang.String)</span><br><span class="line">构造函数[<span class="number">1</span>]:<span class="keyword">public</span> com.example.javabase.User(java.lang.String)</span><br><span class="line">参数类型[<span class="number">1</span>]:(java.lang.String)</span><br><span class="line">构造函数[<span class="number">2</span>]:<span class="keyword">public</span> com.example.javabase.User()</span><br><span class="line">参数类型[<span class="number">2</span>]:()</span><br></pre></td></tr></table></figure><p></p><blockquote><p>关于<strong> Constructor 类本身一些常用方法</strong>如下 (仅部分，其他可查 API)：</p></blockquote><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类，其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor 对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回 Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object... initargs)</td><td>使用此 Constructor 对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table><p>栗子：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">cs3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">System.out.println(<span class="string">&quot;-----getDeclaringClass-----&quot;</span>);</span><br><span class="line">Class uclazz=cs3.getDeclaringClass();</span><br><span class="line"><span class="comment">//Constructor对象表示的构造方法的类</span></span><br><span class="line">System.out.println(<span class="string">&quot;构造方法的类:&quot;</span>+uclazz.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getGenericParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//对象表示此 Constructor 对象所表示的方法的形参类型</span></span><br><span class="line">Type[] tps=cs3.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type tp:tps) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称tp:&quot;</span>+tp);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getParameterTypes-----&quot;</span>);</span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数名称:&quot;</span>+claz.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----getName-----&quot;</span>);</span><br><span class="line"><span class="comment">//以字符串形式返回此构造方法的名称</span></span><br><span class="line">System.out.println(<span class="string">&quot;getName:&quot;</span>+cs3.getName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----getoGenericString-----&quot;</span>);</span><br><span class="line"><span class="comment">//返回描述此 Constructor 的字符串，其中包括类型参数。</span></span><br><span class="line">System.out.println(<span class="string">&quot;getoGenericString():&quot;</span>+cs3.toGenericString());</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-----getDeclaringClass-----</span><br><span class="line">构造方法的类:com.example.javabase.User</span><br><span class="line">-----getGenericParameterTypes-----</span><br><span class="line">参数名称tp:<span class="type">int</span></span><br><span class="line">参数名称tp:<span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">-----getParameterTypes-----</span><br><span class="line">参数名称:<span class="type">int</span></span><br><span class="line">参数名称:java.lang.String</span><br><span class="line">-----getName-----</span><br><span class="line">getName:com.example.javabase.User</span><br><span class="line">-----getoGenericString-----</span><br><span class="line">getoGenericString():<span class="keyword">private</span> com.example.javabase.User(<span class="type">int</span>,java.lang.String)</span><br></pre></td></tr></table></figure><p></p><h3 id="23field类及其用法"><a class="anchor" href="#23field类及其用法">#</a> 2.3Field 类及其用法</h3><blockquote><p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p></blockquote><p>同样的道理，我们可以<strong>通过 Class 类的提供的方法来获取代表字段信息的 Field 对象</strong>，Class 类与 Field 对象相关方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定 name 名称的 (包含 private 修饰的) 字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredField()</td><td>获取 Class 对象所表示的类或接口的所有 (包含 private 修饰的) 字段，不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定 name 名称、具有 public 修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getField()</td><td>获取修饰符为 public 的字段，包含继承字段</td></tr></tbody></table><p>栗子：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field:&quot;</span>+field);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================getDeclaredFields====================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前类所字段(包含private字段),注意不包含父类的字段</span></span><br><span class="line">        Field fields2[] = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2:&quot;</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;field2:&quot;</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br><span class="line">  输出结果: </span><br><span class="line">field:<span class="keyword">public</span> <span class="type">int</span> reflect.Person.age</span><br><span class="line">f:<span class="keyword">public</span> java.lang.String reflect.Student.desc</span><br><span class="line">f:<span class="keyword">public</span> <span class="type">int</span> reflect.Person.age</span><br><span class="line">f:<span class="keyword">public</span> java.lang.String reflect.Person.name</span><br><span class="line"></span><br><span class="line">================getDeclaredFields====================</span><br><span class="line">f2:<span class="keyword">public</span> java.lang.String reflect.Student.desc</span><br><span class="line">f2:<span class="keyword">private</span> <span class="type">int</span> reflect.Student.score</span><br><span class="line">field2:<span class="keyword">public</span> java.lang.String reflect.Student.desc</span><br></pre></td></tr></table></figure><p></p><p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用 Class 类的 getDeclaredField/getDeclaredFields 方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用 Class 类的 getField/getFields，但是也只能获取到 public 修饰的的字段，无法获取父类的私有字段。下面将通过 Field 类本身的方法对指定类属性赋值，代码演示如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class对象引用</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.set(st,<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只获取当前类的字段,不获取父类的字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">descField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">descField.set(st,<span class="string">&quot;I am student&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">scoreField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="comment">//设置可访问，score是private的</span></span><br><span class="line">scoreField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">scoreField.set(st,<span class="number">88</span>);</span><br><span class="line">System.out.println(st.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段值</span></span><br><span class="line">System.out.println(scoreField.get(st));</span><br><span class="line"><span class="comment">// 88</span></span><br></pre></td></tr></table></figure><p></p><p>其中的 ==set (Object obj, Object value)== 方法是 Field 类本身的方法，用于设置字段的值，而 get (Object obj) 则是获取字段的值，当然关于 Field 类还有其他常用的方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td>Class&lt;?&gt;</td><td>getType()</td><td>返回一个 Class 对象，它标识了此 Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td>Class&lt;?&gt;</td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值，即设置其可访问性</td></tr></tbody></table><p>上述方法可能是较为常用的，事实上在设置值的方法上，Field 类还提供了专门针对基本数据类型的方法，如 <code>setInt()/getInt()</code> 、 <code>setBoolean()/getBoolean</code> 、 <code>setChar()/getChar()</code> 等等方法，这里就不全部列出了，需要时查 API 文档即可。需要特别注意的是被 final 关键字修饰的 Field 字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。</p><h3 id="24method类及其用法"><a class="anchor" href="#24method类及其用法">#</a> 2.4Method 类及其用法</h3><blockquote><p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p></blockquote><p>下面是 Class 类获取 Method 对象相关的方法：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</td><td>返回一个指定参数的 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethod</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;... parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共成员方法。</td></tr></tbody></table><p>在通过 getMethods 方法获取 Method 对象时，会把父类的方法也获取到，如上的输出结果，把 Object 类的方法都打印出来了。而 <code>getDeclaredMethod/getDeclaredMethods</code> 方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过 Method 对象调用指定类的方法：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Circle&quot;</span>);</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;draw&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">method.invoke(circle,<span class="number">15</span>,<span class="string">&quot;圈圈&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;drawCircle&quot;</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">method1.invoke(circle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span>clazz.getDeclaredMethod(<span class="string">&quot;getAllCount&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> (Integer) method2.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span>+count);</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw 圈圈,count=<span class="number">15</span></span><br><span class="line">drawCircle</span><br><span class="line">count:<span class="number">100</span></span><br></pre></td></tr></table></figure><p></p><p>在上述代码中调用方法，使用了 Method 类的 ==invoke (Object obj,Object... args)== 第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object... args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td>Class&lt;?&gt;</td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型，即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table><p><code>getReturnType方法/getGenericReturnType方法</code> 都是获取 Method 对象表示的方法的返回类型，只不过前者返回的 Class 类型后者返回的 Type (前面已分析过)，Type 就是一个接口而已，在 Java8 中新增一个默认的方法实现，返回的就参数类型信息</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="comment">//1.8新增</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getTypeName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而 <code>getParameterTypes/getGenericParameterTypes</code> 也是同样的道理，都是获取 Method 对象所表示的方法的参数类型，其他方法与前面的 Field 和 Constructor 是类似的。</p><hr><h1 id="java-泛型"><a class="anchor" href="#java-泛型">#</a> Java--- 泛型</h1><h2 id="1泛型概述"><a class="anchor" href="#1泛型概述">#</a> <strong>1. 泛型概述</strong></h2><blockquote><p>泛型其实就是一种参数化的集合，它限制了你添加进集合的类型。泛型标志就是一种参数化类型。多态也可以看作是泛型的机制。一个类继承了父类，那么就能通过它的父类找到相应的子类，但是不能通过其他类来找到具体要找的这个类。泛型的设计之处就是希望对象或方法具有最广泛的表达能力。</p></blockquote><p>下面看一个例子说明没有泛型的用法：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;cxuan&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> (String)arrayList.get(i);</span><br><span class="line"> System.out.println(<span class="string">&quot;test === &quot;</span>, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段程序不能正常运行，原因是 Integer 类型不能直接强制转换为 String 类型。查询运行后显示报错：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p></p><p>我们用泛型进行改写后，示例代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p></p><p>这段代码在编译期间就会报错，编译器会在编译阶段就能帮我们发现类似这样的问题。</p><h2 id="2泛型的使用"><a class="anchor" href="#2泛型的使用">#</a> <strong>2. 泛型的使用</strong></h2><h3 id="21用泛型表示类"><a class="anchor" href="#21用泛型表示类">#</a> 2.1 用泛型表示类</h3><blockquote><p>泛型可以加到类上面，来表示这个类的类型。</p></blockquote><p>定义格式：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，创建的T，E，K，V等形式的的参数常用于表示泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="comment">//value这个成员变量的类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="22用泛型表示接口"><a class="anchor" href="#22用泛型表示接口">#</a> 2.2 用泛型表示接口</h3><blockquote><p>泛型接口与泛型的定义及使用基本相同。</p><p>一般泛型接口常用于 <code>生成器(generator)</code> 中，生成器相对于对象工厂，是一种专门用来创建对象的类。</p></blockquote><p>定义格式：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Student</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">ppp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="23用泛型表示方法"><a class="anchor" href="#23用泛型表示方法">#</a> 2.3 用泛型表示方法</h3><p>定义格式：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethods</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">      System.out.<span class="built_in">println</span>(x.<span class="built_in">getClass</span>().<span class="built_in">getName</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="24泛型通配符"><a class="anchor" href="#24泛型通配符">#</a> 2.4 泛型通配符</h3><blockquote><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。</p><p>泛型的通配符:<strong> 不知道使用什么类型来接收的时候，此时可以使用？，？表示未知通配符。</strong></p><p>此时只能接受数据，不能往该集合中存储数据。</p></blockquote><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        name.add(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        age.add(<span class="number">20</span>);</span><br><span class="line">        number.add(<span class="number">337</span>);</span><br><span class="line">        generic(name);</span><br><span class="line">        generic(age);</span><br><span class="line">        generic(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generic</span><span class="params">(List&lt;?&gt; data)</span> &#123;</span><br><span class="line">        System.out.println(data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>上界通配符</strong>： <code>&lt;? extends ClassType&gt;</code> 该通配符为 <code>ClassType</code> 的所有子类型。它表示的是任何类型都是 <code>ClassType</code> 类型的子类。</li><li><strong>下界通配符</strong>： <code>&lt;? super ClassType&gt;</code> 该通配符为 <code>ClassType</code> 的所有超类型。它表示的是任何类型的父类都是 <code>ClassType</code> 。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h1 id="java-函数式接口"><a class="anchor" href="#java-函数式接口">#</a> Java--- 函数式接口</h1><h2 id="1自定义函数式接口"><a class="anchor" href="#1自定义函数式接口">#</a> 1. 自定义函数式接口</h2><h3 id="11概述-2"><a class="anchor" href="#11概述-2">#</a> 1.1 概述</h3><p><strong>函数式接口</strong>在 Java 中是指：** 有且仅有一个抽象方法的接口。** 当然接口中可以包含其他的方法（默认，静态，私有）。</p><p>函数式接口，即适用于函数式编程场景的接口。而 Java 中的函数式编程体现就是 Lambda，所以函数式接口就是可 以适用于 Lambda 使用的接口。只有确保接口中有且仅有一个抽象方法，Java 中的 Lambda 才能顺利地进行推导。</p><blockquote><p>备注：“<strong>语法糖</strong>” 是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 for-each 语法，其实 底层的实现原理仍然是迭代器，这便是 “语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部 类的 “语法糖”，但是二者在原理上是不同的。</p></blockquote><h3 id="12格式"><a class="anchor" href="#12格式">#</a> 1.2 格式</h3><p>只要确保接口中有且仅有一个抽象方法即可：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">	<span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于接口当中抽象方法的 <code>public abstract</code> 是可以省略的，所以定义一个函数式接口很简单：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="13functionalinterface注解"><a class="anchor" href="#13functionalinterface注解">#</a> 1.3@FunctionalInterface 注解</h3><p>与 <code>@Override</code> 注解的作用类似，Java 8 中专门为函数式接口引入了一个新的注解： <code>@FunctionalInterface</code> 。该注解可用于一个接口的定义上：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h3 id="14自定义函数式接口"><a class="anchor" href="#14自定义函数式接口">#</a> 1.4 自定义函数式接口</h3><p>对于刚刚定义好的 <code>MyFunctionalInterface</code> 函数式接口，典型使用场景就是作为方法的参数：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MyFunctionalInterface p)</span> &#123;</span><br><span class="line">        p.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象</span></span><br><span class="line">        show(<span class="keyword">new</span> <span class="title class_">xppmzzz</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用show方法，方法的参数是一个接口，所以我们可以传递接口的匿名内部类</span></span><br><span class="line">        show(<span class="keyword">new</span> <span class="title class_">MyFunctionalInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用匿名内部类重写接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//调用show方法，方法的参数是一个函数式接口，所以我们可以用Lambda表达式</span></span><br><span class="line">        show(() -&gt; System.out.println(<span class="string">&quot;使用Lamdba表达式重写接口中的持续方法&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="2函数式编程"><a class="anchor" href="#2函数式编程">#</a> 2. 函数式编程</h2><h3 id="21lambda的延迟执行"><a class="anchor" href="#21lambda的延迟执行">#</a> 2.1Lambda 的延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而 Lambda 表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p><ul><li><p><strong>性能浪费的日志案例</strong></p><p>注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;小皮皮&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;美滋滋&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;哈哈哈&quot;</span>;</span><br><span class="line">        log(<span class="number">1</span>, a + b + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方 法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p><blockquote><p>备注：SLF4J 是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如： LOGGER.debug (&quot;变量 {} 的取值为 {}。&quot;, &quot;os&quot;, &quot;macOS&quot;) ，其中的大括号 {} 为占位 符。如果满足日志级别要求，则会将 “os” 和 “macOS” 两个字符串依次拼接到大括号的位置；否则不会进行字 符串拼接。这也是一种可行解决方案，但 Lambda 可以做到更好。</p></blockquote></li><li><p><strong>体验 Lambda 的更优写法</strong></p><p>使用 Lambda 必然需要一个函数式接口：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageBuilder</span> &#123;</span><br><span class="line">    String <span class="title function_">buildMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后对 log 方法进行改造：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LoggerLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;小皮皮&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;美滋滋&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;哈哈哈&quot;</span>;</span><br><span class="line">        log(<span class="number">1</span>, () -&gt; a + b + c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        log(1, new MessageBuilder() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String buildMessage() &#123;</span></span><br><span class="line"><span class="comment">                return a + b + c;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, MessageBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(builder.buildMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</p></li><li><p><strong>证明 Lambda 的延迟</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LoggerLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;小皮皮&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;美滋滋&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;哈哈哈&quot;</span>;</span><br><span class="line">        log(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda执行！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        log(2, new MessageBuilder() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String buildMessage() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;Lambda执行！&quot;);</span></span><br><span class="line"><span class="comment">                return a + b + c;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="type">int</span> level, MessageBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(builder.buildMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从结果中可以看出，在不符合级别要求的情况下，Lambda 将不会执行。从而达到节省性能的效果。</p><blockquote><p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。</p></blockquote></li></ul><h3 id="22使用lambda作为参数和返回值"><a class="anchor" href="#22使用lambda作为参数和返回值">#</a> 2.2 使用 Lambda 作为参数和返回值</h3><p>如果抛开实现原理不说，Java 中的 Lambda 表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用 Lambda 表达式进行替代。使用 Lambda 表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p><p>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就 可以使用 <code>Lambda</code> 进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startVThread</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        startVThread(() -&gt; System.out.println(<span class="string">&quot;线程任务执行！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个 Lambda 表达式。当需要通过一 个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时，就可以调该方法获取。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] s = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;ppppp&quot;</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">        Arrays.sort(s, newComparator());</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">newComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; b.length() - a.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="3常用函数式接口"><a class="anchor" href="#3常用函数式接口">#</a> 3. 常用函数式接口</h2><blockquote><p>JDK 提供了大量常用的函数式接口以丰富 Lambda 的典型使用场景，它们主要在 java.util.function 包中被提供。 下面是最简单的几个接口及使用示例。</p></blockquote><h3 id="31supplier接口"><a class="anchor" href="#31supplier接口">#</a> 3.1Supplier 接口</h3><p><code>java.util.function.Supplier</code> 接口仅包含一个无参的方法： <code>T get()</code> 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的 <code>Lambda</code> 表达式需要 “对外提供” 一个符合泛型类型的对象数据。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(getString(() -&gt; a + b));</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(getString(new Supplier&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String get() &#123;</span></span><br><span class="line"><span class="comment">                return a + b;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; funcation)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> funcation.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>题目</strong>：使用 Supplier 接口作为方法参数类型，通过 Lambda 表达式求出 int 数组中的最大值。提示：接口的泛型请使用 java.lang.Integer 类。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = &#123;<span class="number">322</span>, <span class="number">24</span>, <span class="number">3</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">53</span>, <span class="number">2544</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxA</span> <span class="operator">=</span> getMax(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : a) &#123;</span><br><span class="line">                max = Math.max(i, max);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        int maxA = getMax(new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">                int max = a[0];</span></span><br><span class="line"><span class="comment">                for (int i : a) &#123;</span></span><br><span class="line"><span class="comment">                    max = Math.max(i, max);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return max;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(maxA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="32consumer接口"><a class="anchor" href="#32consumer接口">#</a> 3.2Consumer 接口</h3><p><code>java.util.function.Consumer</code> 接口则正好与 <code>Supplier</code> 接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。</p><ul><li><p><strong>抽象方法：accept</strong></p><p><code>Consumer</code> 接口中包含抽象方法 <code>void accept(T t)</code> ，意为消费一个指定泛型的数据。基本使用如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        consumeString(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        consumeString(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumeString</span><span class="params">(Consumer&lt;String&gt; function)</span>&#123;</span><br><span class="line">        function.accept(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>默认方法：andThen</strong></p><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的 <code>default</code> 方法 <code>andThen</code> 。下面是 JDK 的源代码：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">		Objects.requireNonNull(after);</span><br><span class="line">		<span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>备注： <code>java.util.Objects</code> 的 <code>requireNonNull</code> 静态方法将会在参数为 null 时主动抛出 <code>NullPointerException</code> 异常。这省去了重复编写 if 语句和抛出空指针异常的麻烦。</p></blockquote><p>要想实现组合，需要两个或多个 <code>Lambda</code> 表达式即可，而 <code>andThen</code> 的语义正是 “一步接一步” 操作。例如两个步骤组合的情况：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        consumString(s-&gt; System.out.println(s.toUpperCase()),s-&gt; System.out.println(s.toLowerCase()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumString</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> &#123;</span><br><span class="line">        one.andThen(two).accept(<span class="string">&quot;xppmzz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>题目</strong>：下面的字符串数组当中存有多条信息，请按照格式 “ <code>姓名：XX。性别：XX。</code> ” 的格式将信息打印出来。要求将打印姓 名的动作作为第一个 <code>Consumer</code> 接口的 <code>Lambda</code> 实例，将打印性别的动作作为第二个 <code>Consumer</code> 接口的 <code>Lambda</code> 实 例，将两个 <code>Consumer</code> 接口按照顺序 “拼接” 到一起。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123;<span class="string">&quot;xpp,男&quot;</span>, <span class="string">&quot;mzz,男&quot;</span>, <span class="string">&quot;hhh,女&quot;</span>&#125;;</span><br><span class="line">        printInfo(s -&gt; System.out.println(<span class="string">&quot;姓名:&quot;</span> + s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]),</span><br><span class="line">                s -&gt; System.out.println(<span class="string">&quot;性别：&quot;</span> + s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]), array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two, String[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">            one.andThen(two).accept(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h3 id="33predicate接口"><a class="anchor" href="#33predicate接口">#</a> 3.3Predicate 接口</h3><p>有时候我们需要对某种类型的数据进行判断，从而得到一个 <code>boolean</code> 值结果。这时可以使用 <code>java.util.function.Predicate</code> 接口。</p><ul><li><p><strong>抽象方法：test</strong></p><p><code>Predicate</code> 接口中包含一个抽象方法： <code>boolean test(T t)</code> 。用于条件判断的场景：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15PredicateTest</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">veryLong</span> <span class="operator">=</span> predicate.test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串很长吗：&quot;</span> + veryLong);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(s ‐&gt; s.length() &gt; <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>默认方法：and</strong></p><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 <code>Predicate</code> 条件使用 “与” 逻辑连接起来实现 “<strong>并且</strong>” 的效果时，可以使用 <code>default</code> 方法 <code>and</code> 。其 JDK 源码为：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">	Objects.requireNonNull(other);</span><br><span class="line">	<span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果要判断一个字符串既要包含大写 “H”，又要包含大写 “W”，那么：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.contains(<span class="string">&quot;H&quot;</span>), s -&gt; s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> one.and(two).test(<span class="string">&quot;HeLLoWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串复合要求吗?&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>默认方法：or</strong></p><p>与 <code>and</code> 的 “与” 类似，默认方法 <code>or</code> 实现逻辑关系中的 “<strong>或</strong>”。JDK 源码为：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">	Objects.requireNonNull(other);</span><br><span class="line">	<span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果希望实现逻辑 “字符串包含大写 H 或者包含大写 W”，那么代码只需要将 “and” 修改为 “or” 名称即可，其他都不 变：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.contains(<span class="string">&quot;H&quot;</span>), s -&gt; s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> one.or(two).test(<span class="string">&quot;heLLoworld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串符合要求吗?&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>默认方法：negate</strong></p><p>“与”、“或” 已经了解了，剩下的 “非”（取反）也会简单。默认方法 <code>negate</code> 的 JDK 源代码为：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从实现中很容易看出，它是执行了 <code>test</code> 方法之后，对结果 <code>boolean</code> 值进行 “!” 取反而已。一定要在 <code>test</code> 方法调用之前 调用 <code>negate</code> 方法，正如 <code>and</code> 和 <code>or</code> 方法一样：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.length() &lt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verLong</span> <span class="operator">=</span> predicate.negate().test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串很长吗？&quot;</span> + verLong);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><p><strong>题目</strong>：数组当中有多条 “姓名 + 性别” 的信息如下，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 <code>ArrayList</code> 中，需要同时满足两个条件：</p><ol><li><p>必须为女生；</p></li><li><p>姓名为 3 个字。</p></li></ol><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainCompartator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123;<span class="string">&quot;xpp,女&quot;</span>, <span class="string">&quot;mzz,男&quot;</span>, <span class="string">&quot;hhh,女&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; ans = method(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() == <span class="number">3</span>, s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>].equals(<span class="string">&quot;女&quot;</span>), array);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two, String[] array)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (one.and(two).test(s))</span><br><span class="line">                res.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="34function接口"><a class="anchor" href="#34function接口">#</a> 3.4Function 接口</h3><p><code>Function</code> 接口 <code>java.util.function.Function</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件， 后者称为后置条件。</p><ul><li><p><strong>抽象方法：apply</strong></p><p><code>Function</code> 接口中最主要的抽象方法为： <code>R apply(T t)</code> ，根据类型 T 的参数获取类型 R 的结果。 使用的场景例如：将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11FunctionApply</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String, Integer&gt; function)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> function.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">		System.out.println(num + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		method(s ‐&gt; Integer.parseInt(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>默认方法：andThen</strong></p><p><code>Function</code> 接口中有一个默认的 <code>andThen</code> 方法，用来进行组合操作。JDK 源代码如：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">	Objects.requireNonNull(after);</span><br><span class="line">	<span class="keyword">return</span> (T t) ‐&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该方法同样用于 “先做什么，再做什么” 的场景，和 Consumer 中的 andThen 差不多：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12FunctionAndThen</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> one.andThen(two).apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">	System.out.println(num + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	method(str‐&gt;Integer.parseInt(str)+<span class="number">10</span>, i ‐&gt; i *= <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第一个操作是将字符串解析成为 int 数字，第二个操作是乘以 10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p><blockquote><p>请注意，Function 的前置条件泛型和后置条件泛型可以相同。</p></blockquote></li></ul><hr><h1 id="缓冲流转换流序列化流打印流"><a class="anchor" href="#缓冲流转换流序列化流打印流">#</a> 缓冲流 + 转换流 + 序列化流 + 打印流</h1><h2 id="1缓冲流"><a class="anchor" href="#1缓冲流">#</a> 1. 缓冲流</h2><h3 id="11概述-3"><a class="anchor" href="#11概述-3">#</a> 1.1 概述</h3><p>缓冲流也叫高效流，是对四个基本的 <code>FileXxx</code> 流的增加，所以也是 4 个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>： <code>BufferedInputStream</code> , <code>BufferedOutputStream</code></li><li><strong>字符缓冲流</strong>： <code>BufferedReader</code> , <code>Bufferedwriter</code></li></ul><p><strong>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率。</strong></p><h3 id="12字节缓冲流"><a class="anchor" href="#12字节缓冲流">#</a> 1.2 字节缓冲流</h3><ol><li><p><strong>构造方法</strong></p><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个新的缓冲输入流。</li><li><code>public BufferedOutputStream(OutputStream out)</code> ：创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>代码演示</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        bo.write(<span class="string">&quot;xppmzz&quot;</span>.getBytes());</span><br><span class="line">        bo.close();</span><br><span class="line">        BufferedInputStream bi=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=bi.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        bi.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="13字符缓冲流"><a class="anchor" href="#13字符缓冲流">#</a> 1.3 字符缓冲流</h3><ol><li><p><strong>构造方法</strong></p><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个新的缓冲输入流。</li><li><code>public BufferedWriter(Writer out)</code> ：创建一个新的缓冲输出流。</li></ul></li><li><p><strong>特有方法</strong></p><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader： <code>public String readLine()</code> : 读一行文字。</li><li>BufferedWriter： <code>public void newLine()</code> : 写一行行分隔符，由系统属性定义符号。</li></ul><p><code>readLine</code> 方法演示，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//定义字符串,保存读取的一行文字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>newLine</code> 方法演示，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	<span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;美滋滋&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">小皮皮</span><br><span class="line">美滋滋</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="2转化流"><a class="anchor" href="#2转化流">#</a> 2. 转化流</h2><h3 id="21字符编码和字符集"><a class="anchor" href="#21字符编码和字符集">#</a> 2.1 字符编码和字符集</h3><ul><li><p><strong>编码</strong>：计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。</p><p>字符 (能看懂的)-- 字节 (看不懂的)</p></li><li><p><strong>解码</strong>：将存储在计算机中的二进制数按照某种规则解析显示出来</p><p>解码：字节 (看不懂的)--&gt; 字符 (能看懂的)</p></li><li><p><strong>字符编码 <code>Character Encoding</code> </strong>: 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表：生活中文字和计算机中二进制的对应规则</p></li><li><p><strong>字符集 <code>Charset</code> </strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有 ASCII 字符集、GBK 字符集、Unicode 字符集等。</p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII 字符集</strong><ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的 ASCII 字符集，使用 7 位（bits）表示一个字符，共 128 字符。ASCII 的扩展字符集使用 8 位（bits）表示一个字符，共 256 字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1 字符集</strong><ul><li>拉丁码表，别名 Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1 使用单字节编码，兼容 ASCII 编码。</li></ul></li><li><strong>GBxxx 字符集</strong><ul><li>GB 就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于 127 的字符的意义与原来相同。但两个大于 127 的字符连在一起时，就表示一个汉字，这样大约可以组合了包含 7000 多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 &quot;全角&quot; 字符，而原来在 127 号以下的那些就叫 &quot;半角&quot; 字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode 字符集</strong><ul><li>Unicode 编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用 4 个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16 和 UTF-32。最为常用的 UTF-8 编码。</li><li><strong>UTF-8 编码</strong>，可以用来表示 Unicode 标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。所以，我们开发 Web 应用，也要使用 UTF-8 编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128 个 US-ASCII 字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。</li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的 Unicode 辅助字符，使用四字节编码。</li></ol></li></ul></li></ul></li></ul><h3 id="22编码引出的问题"><a class="anchor" href="#22编码引出的问题">#</a> 2.2 编码引出的问题</h3><p>在 IDEA 中，使用 <code>FileReader</code> 读取项目中的文本文件。由于 IDEA 的设置，都是默认的 <code>UTF-8</code> 编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p></p><h3 id="23inputstreamreader类"><a class="anchor" href="#23inputstreamreader类">#</a> 2.3InputStreamReader 类</h3><p>转换流 <code>java.io.InputStreamReader</code> ，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ol><li><p><strong>构造方法</strong></p><ul><li><code>InputStreamReader(InputStream in)</code> : 创建一个使用默认字符集的字符流。</li><li><code>InputStreamReader(InputStream in, String charsetName)</code> : 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>指定编码读取</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) read);<span class="comment">//   Һ </span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="24outputstreamwriter类"><a class="anchor" href="#24outputstreamwriter类">#</a> 2.4OutputStreamWriter 类</h3><p>转换流 <code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ol><li><p><strong>构造方法</strong></p><ul><li><code>OutputStreamWriter(OutputStream in)</code> : 创建一个使用默认字符集的字符流。</li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code> : 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>指定编码写出</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="3序列化"><a class="anchor" href="#3序列化">#</a> 3. 序列化</h2><h3 id="31概述"><a class="anchor" href="#31概述">#</a> 3.1 概述</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该 <code>对象的数据</code> 、 <code>对象的类型</code> 和 <code>对象中存储的属性</code> 等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。 <code>对象的数据</code> 、 <code>对象的类型</code> 和 <code>对象中存储的数据</code> 信息，都可以用来在内存中创建对象。看图理解序列化：</p><p>&lt;img src=&quot;file://D:\Java%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91\02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6\day10_%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81Files\img\3_xuliehua.jpg?lastModify=1624601895&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</p><h3 id="32序列化流-objectoutputstream类"><a class="anchor" href="#32序列化流-objectoutputstream类">#</a> 3.2 序列化流 - ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream</code> 类，将 Java 对象的原始数据类型写出到文件，实现对象的持久存储。</p><ol><li><p><strong>构造方法</strong></p><ul><li><code>public ObjectOutputStream(OutputStream out)</code> ： 创建一个指定 OutputStream 的 ObjectOutputStream。</li></ul><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>序列化操作</strong></p><ol><li><p>一个对象要想序列化，必须满足两个条件:</p><ul><li>该类必须实现 <code>java.io.Serializable</code> 接口， <code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出 <code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用 <code>transient</code> 关键字修饰。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pppDemo1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">pppDemo1</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">pppDemo1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">pppDemo1</span>(<span class="string">&quot;小皮皮&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol></li></ol><h3 id="33反序列化流-objectinputstream类"><a class="anchor" href="#33反序列化流-objectinputstream类">#</a> 3.3 反序列化流 - ObjectInputStream 类</h3><p>ObjectInputStream 反序列化流，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。</p><ol><li><p><strong>构造方法</strong></p><ul><li><code>public ObjectInputStream(InputStream in)</code> ： 创建一个指定 InputStream 的 ObjectInputStream。</li></ul></li><li><p><strong>反序列化操作 1</strong></p><p>如果能找到一个对象的 class 文件，我们可以进行反序列化操作，调用 <code>ObjectInputStream</code> 读取对象的方法：</p><ul><li><p><code>public final Object readObject ()</code> : 读取一个对象。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="type">pppDemo1</span> <span class="variable">p</span> <span class="operator">=</span> (pppDemo1) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+p.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+p.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><p><strong>对于 JVM 可以反序列化对象，它必须是能够找到 class 文件的类。如果找不到该类的 class 文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p></li><li><p><strong>反序列化操作 2</strong></p><p>** 另外，当 JVM 反序列化对象时，能找到 class 文件，但是 class 文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个 <code>InvalidClassException</code> 异常。** 发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li><li>该类包含未知数据类型</li><li>该类没有可访问的无参数构造方法</li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。 <code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="34练习序列化集合"><a class="anchor" href="#34练习序列化集合">#</a> 3.4 练习：序列化集合</h3><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ArrayList&lt;pppDemo1&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">pppDemo1</span>(<span class="string">&quot;小皮皮&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        a.add(<span class="keyword">new</span> <span class="title class_">pppDemo1</span>(<span class="string">&quot;美滋滋&quot;</span>, <span class="number">23</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(a);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        ArrayList&lt;pppDemo1&gt; aa = (ArrayList&lt;pppDemo1&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (pppDemo1 p : aa) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">小皮皮---<span class="number">3</span></span><br><span class="line">美滋滋---<span class="number">23</span></span><br></pre></td></tr></table></figure><p></p><h2 id="4打印流"><a class="anchor" href="#4打印流">#</a> 4. 打印流</h2><h3 id="41概述"><a class="anchor" href="#41概述">#</a> 4.1 概述</h3><p>时我们在控制台打印输出，是调用 <code>print</code> 方法和 <code>println</code> 方法完成的，这两个方法都来自于 <code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h3 id="42printstream类"><a class="anchor" href="#42printstream类">#</a> 4.2PrintStream 类</h3><ol><li><p><strong>构造方法</strong></p><ul><li><code>public PrintStream(String fileName)</code> ： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>改变打印流向</strong></p><p><code>System.out</code> 就是 <code>PrintStream</code> 类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个 &quot;小把戏&quot;，改变它的流向。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">	    <span class="comment">// 调用系统的打印流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;控制台输出小皮皮&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置系统的打印流流向,输出到a.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">// 调用系统的打印流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;打印流目的地输出小皮皮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><hr><h1 id="java-面向对象概念总结"><a class="anchor" href="#java-面向对象概念总结">#</a> Java--- 面向对象概念总结</h1><h2 id="1继承"><a class="anchor" href="#1继承">#</a> 1. 继承</h2><h3 id="11继承的特性"><a class="anchor" href="#11继承的特性">#</a> 1.1 继承的特性</h3><ul><li>子类拥有父类非 <code>private</code> 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li><code>Java</code> 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 <code>Java</code> 继承区别于 <code>C++</code> 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h3 id="12继承关键字"><a class="anchor" href="#12继承关键字">#</a> 1.2 继承关键字</h3><p>继承可以使用 <code>extends</code> 和 <code>implements</code> 这两个关键字来实现继承，而且所有的类都是继承于 <code>java.lang.Object</code> ，当一个类没有继承的两个关键字，则默认继承 <code>object</code> （这个类在 <code>java.lang</code> 包中，所以不需要 <code>import</code> ）祖先类。</p><ul><li><p><strong>extends 关键字</strong></p><p>在 <code>Java</code> 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 <code>extends</code> 只能继承一个类。</p></li><li><p><strong>implements 关键字</strong></p><p>使用 <code>implements</code> 关键字可以变相的使 <code>java</code> 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p></li><li><p><strong>super 关键字</strong></p><p><code>super</code> 表示使用它的类的父类。 <code>super</code> 可用于：</p><ul><li>调用父类的构造方法。</li><li>调用父类的方法（子类覆盖了父类的方法时）。</li><li>访问父类的数据域（可以这样用但没有必要这样用）。</li></ul><p>调用父类的构造方法语法：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>();  </span><br><span class="line">或   </span><br><span class="line"><span class="built_in">super</span>(参数列表);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super (); 作为子类构造方法的第一条语句。这会形成一个构造方法链。</p><p>静态方法中不能使用 super 关键字。</p></blockquote><p>调用父类的方法语法：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.方法名(参数列表);</span><br></pre></td></tr></table></figure><p></p><p>如果是继承的方法，是没有必要使用 <code>super</code> 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 <code>super</code> 才能在子类中调用父类中的被重写的方法。</p></li><li><p><strong>this 关键字</strong></p><p><code>this</code> 关键字表示当前对象。可用于：</p><ul><li>调用当前类的构造方法，并且必须是方法的第一条语句。如： <code>this()</code> ; 调用默认构造方法。 <code>this(参数)</code> ; 调用带参构造方法。</li><li>限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 <code>this.num = num</code> 。 <code>this.num</code> 表示当前对象的数据域变量 <code>num</code> ，而 <code>num</code> 表示方法中的局部变量。</li></ul></li><li><p><strong>final 关键字</strong></p><p><code>final</code> 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。</p><ul><li><p>声明类：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> class 类名 &#123;<span class="comment">//类体&#125;</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>声明方法：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">default</span>/<span class="keyword">protected</span>) <span class="keyword">final</span> 返回值类型 方法名()&#123;<span class="comment">//方法体&#125;</span></span><br></pre></td></tr></table></figure><p></p></li></ul></li></ul><h3 id="13构造器"><a class="anchor" href="#13构造器">#</a> 1.3 构造器</h3><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code> 关键字调用父类的构造器并配以适当的参数列表。</p><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <code>super</code> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p><h2 id="2-重写override与重载overload"><a class="anchor" href="#2-重写override与重载overload">#</a> 2. 重写 (Override) 与重载 (Overload)</h2><h3 id="21重写"><a class="anchor" href="#21重写">#</a> 2.1 重写</h3><ol><li><p><strong>重写概述</strong></p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 <code>IOException</code> ，但是在重写这个方法的时候不能抛出 <code>Exception</code> 异常，因为 <code>Exception</code> 是 <code>IOException</code> 的父类，只能抛出 <code>IOException</code> 的子类异常。</p></li><li><p><strong>方法的重写规则</strong></p><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 <code>public</code> ，那么在子类中重写该方法就不能声明为 <code>protected</code> 。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 <code>final</code> 的方法不能被重写。</li><li>声明为 <code>static</code> 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 <code>private</code> 和 <code>final</code> 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 <code>public</code> 和 <code>protected</code> 的非 <code>final</code> 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个类，则不能重写该类的方法。</li></ul></li></ol><h3 id="22重载"><a class="anchor" href="#22重载">#</a> 2.2 重载</h3><ol><li><p><strong>重载概述</strong></p><p>重载 ( <code>overloading</code> ) 是在一个类里面，** 方法名字相同，而参数不同。** 返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载。</p></li><li><p><strong>重载规则</strong></p><ul><li>被重载的方法必须改变参数列表 (参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul></li></ol><h3 id="23重写与重载的区别"><a class="anchor" href="#23重写与重载的区别">#</a> 2.3 重写与重载的区别</h3><table><thead><tr><th style="text-align:left">区别点</th><th style="text-align:left">重载方法</th><th style="text-align:left">重写方法</th></tr></thead><tbody><tr><td style="text-align:left">参数列表</td><td style="text-align:left">必须修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">返回类型</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">异常</td><td style="text-align:left">可以修改</td><td style="text-align:left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td style="text-align:left">访问</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h3 id="24总结"><a class="anchor" href="#24总结">#</a> 2.4 总结</h3><p>方法的重写 ( <code>Overriding</code> ) 和重载 ( <code>Overloading</code> ) 是 java 多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ol><li>方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载 ( <code>Overloading</code> )</li><li>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写 ( <code>Overriding</code> )。</li><li>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</li></ol><h2 id="3多态"><a class="anchor" href="#3多态">#</a> 3. 多态</h2><h3 id="4抽象类"><a class="anchor" href="#4抽象类">#</a> 4. 抽象类</h3><h3 id="41抽象类概述"><a class="anchor" href="#41抽象类概述">#</a> 4.1 抽象类概述</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h3 id="42抽象方法"><a class="anchor" href="#42抽象方法">#</a> 4.2 抽象方法</h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p><code>Abstract</code> 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><h3 id="43抽象类总结"><a class="anchor" href="#43抽象类总结">#</a> 4.3 抽象类总结</h3><ul><li>抽象类不能被实例化 (初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ul><h2 id="5封装"><a class="anchor" href="#5封装">#</a> 5. 封装</h2><h2 id="6接口"><a class="anchor" href="#6接口">#</a> 6. 接口</h2><h3 id="61接口概述"><a class="anchor" href="#61接口概述">#</a> 6.1 接口概述</h3><p>接口（英文： <code>Interface</code> ），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 <code>interface</code> 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 <code>Java</code> 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="62接口与类相似点"><a class="anchor" href="#62接口与类相似点">#</a> 6.2 接口与类相似点</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 <code>.java</code> 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 <code>.class</code> 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="63接口与类的区别"><a class="anchor" href="#63接口与类的区别">#</a> 6.3 接口与类的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 <code>static</code> 和 <code>final</code> 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="64接口特性"><a class="anchor" href="#64接口特性">#</a> 6.4 接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li><li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong> abstract</strong> 关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong> abstract</strong> 关键字。</li><li>接口中的方法都是公有的。</li></ul><h3 id="65接口与抽象类的区别"><a class="anchor" href="#65接口与抽象类的区别">#</a> 6.5 接口与抽象类的区别</h3><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法 (用 <code>static</code> 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h3 id="66接口的实现"><a class="anchor" href="#66接口的实现">#</a> 6.6 接口的实现</h3><ol><li><strong>重写接口中声明的方法时，需要注意以下规则</strong><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul></li><li><strong>在实现接口的时候，也要注意一些规则</strong><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul></li></ol><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><p><strong>注</strong>：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为 &quot;默认方法&quot;，默认方法使用 default 关键字修饰。</p><p><strong>注</strong>：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p></blockquote><hr><h1 id="字节流and字符流"><a class="anchor" href="#字节流and字符流">#</a> 字节流 and 字符流</h1><h2 id="一io概述"><a class="anchor" href="#一io概述">#</a> 一.IO 概述</h2><h3 id="1io的分类"><a class="anchor" href="#1io的分类">#</a> 1.IO 的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流。</strong></p><ul><li><strong>输入流</strong> ：把数据从 <code>其他设备</code> 上读取到 <code>内存</code> 中的流。</li><li><strong>输出流</strong> ：把数据从 <code>内存</code> 中写出到 <code>其他设备</code> 上的流。</li></ul><p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h3 id="2顶级父类们"><a class="anchor" href="#2顶级父类们">#</a> 2. 顶级父类们</h3><table><thead><tr><th></th><th style="text-align:center">输入流</th><th style="text-align:center">输出流</th></tr></thead><tbody><tr><td>字节流</td><td style="text-align:center">字节输入流 <code>InputStream</code></td><td style="text-align:center">字节输出流 <code>OutputStream</code></td></tr><tr><td>字符流</td><td style="text-align:center">字符输入流 <code>Reader</code></td><td style="text-align:center">字符输出流 <code>Writer</code></td></tr></tbody></table><h2 id="二字节流"><a class="anchor" href="#二字节流">#</a> 二。字节流</h2><h3 id="1字节输出流outputstream"><a class="anchor" href="#1字节输出流outputstream">#</a> 1. 字节输出流 <code>OutputStream</code></h3><p><code>java.io.OutputStream</code> <strong>抽象类</strong>是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><code>public void write(byte[] b)</code> ：将 b.length 字节从指定的字节数组写入此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。</li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close 方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="2fileoutputstream类"><a class="anchor" href="#2fileoutputstream类">#</a> 2.FileOutputStream 类</h3><p><code>OutputStream</code> 有很多子类，我们从最简单的一个子类 <code>FileOutputStream</code> 开始。</p><p><code>java.io.FileOutputStream</code> 类是文件输出流，用于将数据写出到文件。</p><h4 id="1构造方法"><a class="anchor" href="#1构造方法">#</a> (1) 构造方法</h4><ul><li><code>public FileOutputStream(File file)</code> : 创建文件输出流以写入由指定的 File 对象表示的文件。</li><li><code>public FileOutputStream(String name</code> : 创建文件输出流以指定的名称写入文件</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li><p>构造举例</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamConstructor</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h4 id="2写出字节数据"><a class="anchor" href="#2写出字节数据">#</a> (2) 写出字节数据</h4><ol><li><p><strong>写出字节</strong>： <code>write(int b)</code> 方法，每次可以写出一个字节数据。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><ol><li>虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用 close 方法，千万记得。</li></ol></blockquote></li><li><p><strong>写出字节数组</strong>: <code>write(byte[] b)</code> ，每次可以写出数组中的数据。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;小屁屁&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">小屁屁</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>写出指定长度字节数组</strong>： <code>write(btye[] b,int off,int len)</code> ，每次写出从 off 索引开始，len 个字节。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure><p></p></li></ol><h4 id="3数据追加续写"><a class="anchor" href="#3数据追加续写">#</a> (3) 数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code> ： 创建文件输出流以写入由指定的 File 对象表示的文件。</li><li><code>public FileOutputStream(String name, boolean append)</code> ： 创建文件输出流以指定的名称写入文件。</li></ul><p>这两个构造方法，参数中都需要传入一个 boolean 类型的值， <code>true</code> 表示追加数据， <code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;xpp.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">       <span class="type">byte</span>[] b=<span class="string">&quot;xpp&quot;</span>.getBytes();</span><br><span class="line">       fos.write(b);</span><br><span class="line">       fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：你好</span><br><span class="line">文件操作后：你好xpp</span><br></pre></td></tr></table></figure><p></p><ol start="4"><li><p><strong>写出换行</strong></p><p>Windows 系统里，换行符号是 <code>\r\n</code> 。把以指定是否追加续写了代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="type">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><p></p><blockquote><ul><li>回车符 <code>\r</code> 和换行符 <code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows 系统里，每行结尾是 <code>回车+换行</code> ，即 <code>\r\n</code> ；</li><li>Unix 系统里，每行结尾只有 <code>换行</code> ，即 <code>\n</code> ；</li><li>Mac 系统里，每行结尾是 <code>回车</code> ，即 <code>\r</code> 。从 Mac OS X 开始与 Linux 统一。</li></ul></li></ul></blockquote></li></ol><h3 id="3字节输入流inputstream"><a class="anchor" href="#3字节输入流inputstream">#</a> 3. 字节输入流 [InputStream]</h3><p><code>java.io.InputStream</code> 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li><li><code>public abstract int read()</code> ： 从输入流读取数据的下一个字节。</li><li><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b 中 。</li></ul><blockquote><p>小贴士：</p><p>close 方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="4-fileinputstream类"><a class="anchor" href="#4-fileinputstream类">#</a> 4. FileInputStream 类</h3><p><code>java.io.FileInputStream</code> 类是文件输入流，从文件中读取字节。</p><h4 id="1构造方法-2"><a class="anchor" href="#1构造方法-2">#</a> (1) 构造方法</h4><ul><li><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File 对象 file 命名。</li><li><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出 <code>FileNotFoundException</code> 。</p><ul><li><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamConstructor</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h4 id="2读取字节数据"><a class="anchor" href="#2读取字节数据">#</a> (2) 读取字节数据</h4><ol><li><p><strong>读取字节</strong>： <code>read</code> 方法，每次可以读取一个字节的数据，提升为 int 类型，读取到文件末尾，返回 <code>-1</code> ，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure><p></p><p>循环改进读取方式，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> read=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((read=fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为 int 类型。</li><li>流操作完毕后，必须释放系统资源，调用 close 方法，千万记得。</li></ol></li><li><p><strong>使用字节数组读取</strong>： <code>read(byte[] b)</code> ，每次读取 b 的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回 <code>-1</code> ，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure><p></p><p>错误数据 <code>d</code> ，是由于最后一次读取时，只读取一个字节 <code>e</code> ，数组中，上次读取的数据没有被完全替换，所以要通过 <code>len</code> ，获取有效的字节，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的 IO 操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote></li></ol><h3 id="5字节流练习图片复制"><a class="anchor" href="#5字节流练习图片复制">#</a> 5. 字节流练习：图片复制</h3><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\image\\img1.png&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\image\\img2.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><p>流的关闭原则：先开后关，后开先关。</p></blockquote><h2 id="三字符流"><a class="anchor" href="#三字符流">#</a> 三。字符流</h2><blockquote><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以 Java 提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p></blockquote><h3 id="1字符输入流reader"><a class="anchor" href="#1字符输入流reader">#</a> 1. 字符输入流 [Reader]</h3><p><code>java.io.Reader</code> 抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li><li><code>public int read()</code> ：从输入流读取一个字符。</li><li><code>public int read(char[] cbuf)</code> ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。</li></ul><h3 id="2filereader类"><a class="anchor" href="#2filereader类">#</a> 2.FileReader 类</h3><p><code>java.io.FileReader</code> 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows 系统的中文编码默认是 GBK 编码表。</p><p>idea 中 UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h4 id="1构造方法-3"><a class="anchor" href="#1构造方法-3">#</a> (1) 构造方法</h4><ul><li><code>FileReader(File file)</code> ：创建一个新的 FileReader，给定要读取的 File 对象。</li><li><code>FileReader(String fileName)</code> ：创建一个新的 FileReader，给定要读取的文件的名称。</li></ul><p>当年创建一个流对象时，必须传入一个文件路径。类似于 <code>FileInputStream</code> .</p><ul><li><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h4 id="2读取字符数据"><a class="anchor" href="#2读取字符数据">#</a> (2) 读取字符数据</h4><ol><li><p><strong>读取字符</strong>： <code>read</code> 方法，每次可以读取一个字符的数据，提升为 int 类型，读取到文件末尾，返回 <code>-1</code> ，循环读取，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为 int 类型。</p></blockquote></li><li><p><strong>使用字符数组读取</strong>： <code>read(char[] cbuf)</code> , 每次读取 b 的长度个字符到数组中，返回读取到的有效个字符个数，读取到末尾时，返回 <code>-1</code> ，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(c)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(c));</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>获取有效的字符改进，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(c)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(c,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><h3 id="3字符输出流writer"><a class="anchor" href="#3字符输出流writer">#</a> 3. 字符输出流 [Writer]</h3><p><code>java.io.Writer</code> 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字符输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code> 写入字符数组。</li><li><code>abstract void write(char[] cbuf, int off, int len)</code> 写入字符数组的某一部分，off 数组的开始索引，len 写的字符个数。</li><li><code>void write(String str)</code> 写入字符串。</li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分，off 字符串的开始索引，len 写的字符个数。</li><li><code>void flush()</code> 刷新该流的缓冲。</li><li><code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h3 id="4filewriter类"><a class="anchor" href="#4filewriter类">#</a> 4.FileWriter 类</h3><p><code>java.io.FileWriter</code> 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h4 id="1构造方法-4"><a class="anchor" href="#1构造方法-4">#</a> (1) 构造方法</h4><ul><li><code>FileWriter(File file)</code> : 创建一个新的 FileWriter，给定要读取的 File 对象。</li><li><code>FileWriter(String fileName)</code> : 创建一个新的 FileWriter，给定要读取的文件名称。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于 <code>FileOutputStream</code> 。</p><ul><li><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw1=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">        </span><br><span class="line">        FileWriter fw2=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h4 id="2基本写出数据"><a class="anchor" href="#2基本写出数据">#</a> (2) 基本写出数据</h4><ol><li><p><strong>写出字符</strong>： <code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：</p><ol><li>虽然参数为 int 类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用 close 方法，数据只是保存到了缓冲区，并未写出到文件。</li></ol></blockquote></li></ol><h4 id="3关闭和刷新"><a class="anchor" href="#3关闭和刷新">#</a> (3) 关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 <code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code> : 先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：即便是 flush 方法写出了数据，操作的最后还是要调用 close 方法，释放系统资源。</p></blockquote><h4 id="4写出其它数据"><a class="anchor" href="#4写出其它数据">#</a> (4) 写出其它数据</h4><ol><li><p><strong>写出字符数组</strong>： <code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似 FileOutputStream，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] c=<span class="string">&quot;小皮皮美滋滋&quot;</span>.toCharArray();</span><br><span class="line">        fw.write(c);</span><br><span class="line">        fw.write(c,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>写出字符串</strong>： <code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        String s=<span class="string">&quot;小皮皮美滋滋&quot;</span>;</span><br><span class="line">        fw.write(s);</span><br><span class="line">        fw.write(s,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>续写和换行</strong>：操作类似于 FileOutputStream。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        String s=<span class="string">&quot;小皮皮美滋滋&quot;</span>;</span><br><span class="line">        fw.write(s);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        fw.write(s,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p><p>当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</p></blockquote></li></ol><h2 id="四io异常的处理"><a class="anchor" href="#四io异常的处理">#</a> 四.IO 异常的处理</h2><h3 id="1jdk7前处理"><a class="anchor" href="#1jdk7前处理">#</a> 1.JDK7 前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用 <code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandleException1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="2jdk7的处理"><a class="anchor" href="#2jdk7的处理">#</a> 2.JDK7 的处理</h3><p>还可以使用 JDK7 优化后的 <code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">&#x27;;&#x27;</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;a.txt&quot;</span>)) &#123;</span><br><span class="line">            fw.write(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="3jdk9的改进扩展知识点了解内容"><a class="anchor" href="#3jdk9的改进扩展知识点了解内容">#</a> 3.JDK9 的改进 (扩展知识点了解内容)</h3><p>JDK9 中 <code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动 close，我们来了解一下格式。</p><p>改进前格式：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">r1</span> <span class="operator">=</span> resource1;</span><br><span class="line">     <span class="type">Resource</span> <span class="variable">r2</span> <span class="operator">=</span> resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>改进后格式：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>改进后，代码使用演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  <span class="type">FileReader</span> <span class="variable">fr</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="五属性集"><a class="anchor" href="#五属性集">#</a> 五。属性集</h2><h3 id="1构造方法-5"><a class="anchor" href="#1构造方法-5">#</a> 1. 构造方法</h3><ul><li><code>public Properties()</code> : 创建一个空的属性列表。</li></ul><h3 id="2基本的存储方法"><a class="anchor" href="#2基本的存储方法">#</a> 2. 基本的存储方法</h3><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。</li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        p.setProperty(<span class="string">&quot;xpp&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        p.setProperty(<span class="string">&quot;mzz&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">        ;</span><br><span class="line">        p.setProperty(<span class="string">&quot;lbj&quot;</span>, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;xpp&quot;</span>));</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;mzz&quot;</span>));</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;lbj&quot;</span>));</span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;ppp&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; s = p.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s1 : s) &#123;</span><br><span class="line">            System.out.println(s1 + <span class="string">&quot;-----&quot;</span> + p.getProperty(s1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;mzz=<span class="number">222</span>, xpp=<span class="number">111</span>, lbj=<span class="number">333</span>&#125;</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">mzz-----<span class="number">222</span></span><br><span class="line">xpp-----<span class="number">111</span></span><br><span class="line">lbj-----<span class="number">333</span></span><br></pre></td></tr></table></figure><p></p><h3 id="3与流相关的方法"><a class="anchor" href="#3与流相关的方法">#</a> 3. 与流相关的方法</h3><ul><li><code>public void load(InputStream inStream)</code> ： 从字节输入流中读取键值对。</li></ul><p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure><p></p><p>加载代码演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        p.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; strings = p.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            System.out.println(string + <span class="string">&quot;----&quot;</span> + p.getProperty(string));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><hr><h1 id="一list"><a class="anchor" href="#一list">#</a> 一.List</h1><h2 id="11list接口概述"><a class="anchor" href="#11list接口概述">#</a> 1.1List 接口概述</h2><blockquote><p><code>java.util.List</code> 接口继承自 <code>Collection</code> 接口，是单列集合的一个重要分支，习惯性地会将实现了 <code>List</code> 接口的对象称为 List 集合。在 List 集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List 集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p></blockquote><p><strong>List 接口特点：</strong></p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是 11、22、33。那么集合中，元素的存储就是按照 11、22、33 的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的 equals 方法，来比较是否为重复的元素。</li></ol><h2 id="12list接口中常用方法"><a class="anchor" href="#12list接口中常用方法">#</a> 1.2List 接口中常用方法</h2><blockquote><p>List 作为 Collection 集合的子接口，不但继承了 Collection 接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。</p></blockquote><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>public void add(int index,E element)</code></td><td>将指定的元素，添加到该集合中的指定位置上。</td></tr><tr><td><code>public E get(int index)</code></td><td>返回集合中指定位置的元素</td></tr><tr><td><code>public E remove(int index)</code></td><td>移除表中指定位置的元素，返回被移除元素。</td></tr><tr><td><code>public E set(int index,E element)</code></td><td>用指定元素替换集合中指定位置的元素，并返回更新前的元素。</td></tr></tbody></table><h2 id="13arraylist集合"><a class="anchor" href="#13arraylist集合">#</a> 1.3ArrayList 集合</h2><blockquote><p><code>java.util.ArrayList</code> 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以 <code>ArrayList</code> 是最常用的集合。</p><p>许多程序员开发时非常随意地使用 ArrayList 完成任何需求，并不严谨，这种用法是不提倡的。</p></blockquote><h2 id="14linkedlist集合"><a class="anchor" href="#14linkedlist集合">#</a> 1.4LinkedList 集合</h2><p><code>java.util.LinkedList</code> 集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而 LinkedList 提供了大量首尾操作的方法。在开发时，LinkedList 集合也可以作为堆栈，队列的结构使用。</p><blockquote><p>LinkedList 是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>public void addFirst(E e)</code></td><td>将指定元素插入此列表的开头。</td></tr><tr><td><code>public void addLast(E e)</code></td><td>将指定元素添加到此列表的结尾。</td></tr><tr><td><code>public E getFirst()</code></td><td>返回此列表的第一个元素。</td></tr><tr><td><code>public E getLast()</code></td><td>返回此列表的最后一个元素。</td></tr><tr><td><code>public E removeFirst()</code></td><td>移除并返回此列表的第一个元素。</td></tr><tr><td><code>public E removeLast()</code></td><td>移除并返回此列表的最后一个元素。</td></tr><tr><td><code>public E pop()</code></td><td>从此列表所表示的堆栈处弹出一个元素。</td></tr><tr><td><code>public void push(E e)</code></td><td>将元素推入此列表所表示的堆栈。</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>如果列表不包含元素，则返回 true。</td></tr></tbody></table><h1 id="二set"><a class="anchor" href="#二set">#</a> 二.Set</h1><h2 id="21set接口概述"><a class="anchor" href="#21set接口概述">#</a> 2.1Set 接口概述</h2><blockquote><p><code>java.util.Set</code> 接口和 <code>java.util.List</code> 接口一样，同样继承自 <code>Collection</code> 接口，它与 <code>Collection</code> 接口中的方法基本一致，并没有对 <code>Collection</code> 接口进行功能上的扩充，只是比 <code>Collection</code> 接口更加严格了。与 <code>List</code> 接口不同的是，<strong> <code>Set</code> 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</strong></p></blockquote><h2 id="22hashset集合"><a class="anchor" href="#22hashset集合">#</a> 2.2HashSet 集合</h2><p><code>java.util.HashSet</code> 是 <code>Set</code> 接口的一个实现类，它所存储的<strong>元素是不可重复的，并且元素都是无序的 (即存取顺序不一致)。</strong> <code>java.util.HashSet</code> 底层的实现其实是一个 <code>java.util.HashMap</code> 支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code> 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： <code>hashCode</code> 与 <code>equals</code> 方法。</p><h2 id="23hashset集合存储数据的结构哈希表"><a class="anchor" href="#23hashset集合存储数据的结构哈希表">#</a> 2.3HashSet 集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong> JDK1.8</strong> 之前，哈希表底层采用<strong>数组 + 链表</strong>实现，即使用链表处理冲突，同一 hash 值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。而 JDK1.8 中，哈希表存储采用<strong>数组 + 链表 + 红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>总而言之，<strong>JDK1.8</strong> 引入红黑树大程度优化了 HashMap 的性能，那么对于我们来讲保证 HashSet 集合元素的唯一，其实就是根据对象的 hashCode 和 equals 方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写 hashCode 和 equals 方法建立属于当前对象的比较方式。</p><h2 id="24hashset存储自定义类型元素"><a class="anchor" href="#24hashset存储自定义类型元素">#</a> 2.4HashSet 存储自定义类型元素</h2><p>给 HashSet 中存放自定义类型元素时，需要重写对象中的 hashCode 和 equals 方法，建立自己的比较方式，才能保证 HashSet 集合中的对象唯一。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == s.age &amp;&amp; Objects.equals(name, s.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot;----&gt;&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        s.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小皮皮&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        s.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;美滋滋&quot;</span>, <span class="number">233</span>));</span><br><span class="line">        s.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小皮皮&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        s.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;哈哈哈&quot;</span>, <span class="number">13</span>));</span><br><span class="line">        <span class="keyword">for</span> (Student s1 : s) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">哈哈哈----&gt;<span class="number">13</span></span><br><span class="line">美滋滋----&gt;<span class="number">233</span></span><br><span class="line">小皮皮----&gt;<span class="number">23</span></span><br></pre></td></tr></table></figure><p></p><h2 id="25linkedhashset"><a class="anchor" href="#25linkedhashset">#</a> 2.5LinkedHashSet</h2><p>我们知道 HashSet 保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在 HashSet 下面有一个子类 <code>java.util.LinkedHashSet</code> ，它是链表和哈希表组合的一个数据存储结构。</p><p>代码演示：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="number">323</span>);</span><br><span class="line">        a.add(<span class="number">1323</span>);</span><br><span class="line">        a.add(<span class="number">23</span>);</span><br><span class="line">        a.add(<span class="number">234</span>);</span><br><span class="line">        a.add(<span class="number">23</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; it = a.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"><span class="number">323</span></span><br><span class="line"><span class="number">1323</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">234</span></span><br></pre></td></tr></table></figure><p></p><h1 id="三collections"><a class="anchor" href="#三collections">#</a> <strong>三.Collections</strong></h1><h2 id="31常用功能"><a class="anchor" href="#31常用功能">#</a> 3.1 常用功能</h2><p><code>java.utils.Collections</code> 是集合工具类，用来对集合进行操作。部分方法如下：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code></td><td>往集合中添加一些元素。</td></tr><tr><td><code>public static void shuffle(List&lt;?&gt; list)</code></td><td>打乱集合顺序。</td></tr><tr><td><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code></td><td>将集合中元素按照默认规则排序。</td></tr><tr><td><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code></td><td>将集合中元素按照指定规则排序。</td></tr></tbody></table><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; a=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="number">232</span>);</span><br><span class="line">        a.add(<span class="number">23</span>);</span><br><span class="line">        a.add(<span class="number">132</span>);</span><br><span class="line">        a.add(<span class="number">132</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        Collections.addAll(a,<span class="number">13</span>,<span class="number">3242</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        Collections.shuffle(a);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        Collections.sort(a);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        Collections.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">232</span>, <span class="number">23</span>, <span class="number">132</span>, <span class="number">132</span>]</span><br><span class="line">[<span class="number">232</span>, <span class="number">23</span>, <span class="number">132</span>, <span class="number">132</span>, <span class="number">13</span>, <span class="number">3242</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">132</span>, <span class="number">23</span>, <span class="number">232</span>, <span class="number">13</span>, <span class="number">3242</span>, <span class="number">132</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">13</span>, <span class="number">23</span>, <span class="number">132</span>, <span class="number">132</span>, <span class="number">232</span>, <span class="number">3242</span>]</span><br><span class="line">[<span class="number">3242</span>, <span class="number">232</span>, <span class="number">132</span>, <span class="number">132</span>, <span class="number">23</span>, <span class="number">13</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p></p><h2 id="32comparator比较器"><a class="anchor" href="#32comparator比较器">#</a> 3.2Comparator 比较器</h2><p>我们还是先研究这个方法</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> : 将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><p></p><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在 JAVA 中提供了两种比较实现的方式，一种是比较死板的采用 <code>java.lang.Comparable</code> 接口去实现，一种是灵活的当我需要做排序的时候在去选择的 <code>java.util.Comparator</code> 接口完成。</p><p>那么我们采用的 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code> 这个方法完成的排序，实际上要求了被排序的类型需要实现 Comparable 接口完成比较的功能。</p><p>String 类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改 String 的源代码，这是不可能的了，那么这个时候我们可以使用</p><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code> 方法灵活的完成，这个里面就涉及到了 Comparator 这个接口，位于位于 java.util 包下，排序是 comparator 能实现的功能之一，该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p><ul><li><p><code>public int compare(String o1, String o2)</code> ：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则 o1 小于 o2，返回（负数），相等返回 0，01 大于 02 返回（正数）<br>如果要按照降序排序<br>则 o1 小于 o2，返回（正数），相等返回 0，01 大于 02 返回（负数）</p></blockquote></li></ul><p>操作如下:</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果如下：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><p></p><h2 id="33-简述comparable和comparator两个接口的区别"><a class="anchor" href="#33-简述comparable和comparator两个接口的区别">#</a> 3.3 简述 Comparable 和 Comparator 两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。只能在类中实现 compareTo () 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>：强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p><hr><h1 id="map"><a class="anchor" href="#map">#</a> Map</h1><h2 id="一map集合"><a class="anchor" href="#一map集合">#</a> 一.Map 集合</h2><h3 id="11概述-4"><a class="anchor" href="#11概述-4">#</a> 1.1 概述</h3><blockquote><p>现实生活中，我们常会看到这样的一种集合：IP 地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java 提供了专门的集合类用来存放这种对象关系的对象，即 <code>java.util.Map</code> 接口。</p></blockquote><p><strong><code>Map</code> 接口和 <code>Collection</code> 接口对比</strong>：</p><ul><li><code>Collection</code> 中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code> 中的集合，元素是成对存在的 (理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值</li><li><code>Collection</code> 中的集合称为单列集合， <code>Map</code> 中的集合称为双列集合。</li><li>需要注意的是， <code>Map</code> <strong>中的集合不能包含重复的键，值可以重复</strong>；<strong>每个键只能对应一个值</strong>。</li></ul><h3 id="12map常用子类"><a class="anchor" href="#12map常用子类">#</a> 1.2Map 常用子类</h3><ul><li><p><code>HashMap&lt;K,V&gt;</code></p><p>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的 hashCode () 方法、equals () 方法。</p></li><li><p><code>LinkedHashMap&lt;K,V&gt;</code></p><p>HashMap 下有个子类 LinkedHashMap，存储数据采用的哈希表结构 + 链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode () 方法、equals () 方法。</p></li></ul><h3 id="13map接口中的常用方法"><a class="anchor" href="#13map接口中的常用方法">#</a> 1.3Map 接口中的常用方法</h3><ul><li><p><code>public V put(K key,V value)</code></p><p>把指定的键与指定的值添加到 Map 集合中。</p></li><li><p><code>public V remove(Object key)</code></p><p>把指定的键 所对应的键值对元素 在 Map 集合中删除，返回被删除元素的值。</p></li><li><p><code>public V get(Object key)</code></p><p>根据指定的键，在 Map 集合中获取对应的值。</p></li><li><p><code>boolean containsKey(Object key)</code></p><p>判断集合中是否包含指定的键。</p></li><li><p><code>public Set&lt;K&gt; keySet()</code></p><p>获取 Map 集合中所有的键，存储到 Set 集合中。</p></li><li><p><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></p><p>获取到 Map 集合中所有的键值对对象的集合 (Set 集合)。</p><p>Entry 表示了一对键和值，提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code> ：获取 Entry 对象中的键。</li><li><code>public V getValue()</code> ：获取 Entry 对象中的值。</li></ul></li></ul><p>示例：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        mp.put(<span class="string">&quot;小皮皮&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        mp.put(<span class="string">&quot;美滋滋&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        mp.put(<span class="string">&quot;啦啦啦&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(mp);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> mp.remove(<span class="string">&quot;小皮皮&quot;</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(mp);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> mp.get(<span class="string">&quot;啦啦啦&quot;</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> mp.put(<span class="string">&quot;美滋滋&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = mp.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> mp.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-----&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; es = mp.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : es) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-----&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;美滋滋=<span class="number">6</span>, 小皮皮=<span class="number">23</span>, 啦啦啦=<span class="number">0</span>&#125;</span><br><span class="line"><span class="number">23</span></span><br><span class="line">&#123;美滋滋=<span class="number">6</span>, 啦啦啦=<span class="number">0</span>&#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">美滋滋-----<span class="number">12</span></span><br><span class="line">啦啦啦-----<span class="number">0</span></span><br><span class="line">美滋滋-----<span class="number">12</span></span><br><span class="line">啦啦啦-----<span class="number">0</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>tips:</p><p>使用 put 方法时，若指定的键 (key) 在集合中没有，则没有这个键对应的值，返回 null，并把指定的键值添加到集合中；</p><p>若指定的键 (key) 在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p></blockquote><h3 id="14hashmap存储自定义类型键值"><a class="anchor" href="#14hashmap存储自定义类型键值">#</a> 1.4HashMap 存储自定义类型键值</h3><h3 id="15linkedhashmap"><a class="anchor" href="#15linkedhashmap">#</a> 1.5LinkedHashMap</h3><p>我们知道 HashMap 保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p><p>在 HashMap 下面有一个子类 LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainIo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        LinkedHashMap&lt;String, Integer&gt; lmp = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        lmp.put(<span class="string">&quot;小皮皮&quot;</span>, <span class="number">111</span>);</span><br><span class="line">        lmp.put(<span class="string">&quot;hhh&quot;</span>, <span class="number">333</span>);</span><br><span class="line">        lmp.put(<span class="string">&quot;美滋滋&quot;</span>, <span class="number">222</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; e = lmp.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; ee : e) &#123;</span><br><span class="line">            System.out.println(ee.getKey() + <span class="string">&quot;----&quot;</span> + ee.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小皮皮----111</span><br><span class="line">hhh----333</span><br><span class="line">美滋滋----222</span><br></pre></td></tr></table></figure><p></p><hr><h1 id="java-注解"><a class="anchor" href="#java-注解">#</a> Java--- 注解</h1><ul><li><p><strong>概念</strong>：说明程序的。给计算机看的。</p></li><li><p><strong>注释</strong>：用文字描述程序的。给程序员看的</p></li><li><p><strong>定义</strong>：注解（Annotation），也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p><strong>概念描述</strong>：</p><ul><li>JDK1.5 之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p><strong>作用分类</strong>：<br><strong>①编写文档</strong>：通过代码里标识的注解生成文档【生成文档 doc 文档】<br><strong>②代码分析</strong>：通过代码里标识的注解对代码进行分析【使用反射】<br><strong>③编译检查</strong>：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</p></li><li><p><strong>JDK 中预定义的一些注解</strong></p><ul><li><strong>@Override</strong>	：检测被该注解标注的方法是否是继承自父类 (接口) 的</li><li><strong>@Deprecated</strong>：该注解标注的内容，表示已过时</li><li><strong>@SuppressWarnings</strong>：压制警告<ul><li>一般传递参数 all @SuppressWarnings (&quot;all&quot;)</li></ul></li></ul></li><li><p><strong>自定义注解</strong></p><ul><li><p>格式：<br>元注解<br>public @interface 注解名称 {<br>属性列表；<br>}</p></li><li><p>本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li><li><p>属性：接口中的抽象方法</p><ul><li>要求：<ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值</p><ol><li>如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可。</li><li>数组赋值时，值使用 {} 包裹。如果数组中只有一个值，则 {} 可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType 取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li>@Retention (RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到</li></ul></li><li>@Documented：描述注解是否被抽取到 api 文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul></li></ul><hr><h1 id="网络编程"><a class="anchor" href="#网络编程">#</a> 网络编程</h1><h2 id="1网络编程入门"><a class="anchor" href="#1网络编程入门">#</a> 1. 网络编程入门</h2><h3 id="11软件结构"><a class="anchor" href="#11软件结构">#</a> 1.1 软件结构</h3><ul><li><p><strong>C/S 结构</strong>：全称 Client/Server 结构，是指<strong>客户端和服务器</strong>结构。常见程序有 QQ，迅雷等软件。</p><p>&lt;img src=&quot;file://D:/Java%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/1_cs.jpg?lastModify=1624613454&quot; alt=&quot;img&quot; style=&quot;zoom: 80%;&quot; /&gt;</p></li><li><p><strong>B/S 结构</strong>：全称为 Brower/Server 结构，是指<strong>浏览器和服务器</strong>结构。常见浏览器有谷歌，火狐等。</p><p>&lt;img src=&quot;file://D:\Java%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91\02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6\day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\img\2_bs.jpg?lastModify=1624617817&quot; alt=&quot;img&quot; style=&quot;zoom:80%;&quot; /&gt;</p></li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h3 id="12网络通信协议"><a class="anchor" href="#12网络通信协议">#</a> 1.2 网络通信协议</h3><ul><li><p><strong>网络通信协议</strong></p><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p></li><li><p><strong>TCP/IP 协议</strong></p><p><strong>传输控制协议</strong> /<strong> 因特网互联协议</strong> (Transmission Control Protocol/Internet Protocol)，是 Internet 最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了 4 层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p><p>&lt;img src=&quot;file://D:/Java%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/3_tcp_ip.jpg?lastModify=1624625806&quot; alt=&quot;img&quot; style=&quot;zoom: 80%;&quot; /&gt;</p><ul><li><strong>链路层</strong>：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li><li><strong>网络层</strong>：网络层是整个 TCP/IP 协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li><li><strong>运输层</strong>：主要使网络程序进行通信，在进行网络通信时，可以采用 TCP 协议，也可以采用 UDP 协议。</li><li><strong>应用层</strong>：主要负责应用程序的协议，例如 HTTP 协议、FTP 协议等。</li></ul></li></ul><h3 id="13协议分类"><a class="anchor" href="#13协议分类">#</a> 1.3 协议分类</h3><blockquote><p>通信的协议还是比较复杂的， <code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p></blockquote><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong></p><p><strong>用户数据报协议</strong> (User Datagram Protocol)。<strong>UDP 是无连接通信协议</strong>，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。</p><p><strong>特点</strong>：数据被限制在 64kb 以内，超出这个范围就不能发送了。</p><p><strong>数据报 (Datagram)</strong>：网络传输的基本单位 。</p></li><li><p><strong>TCP</strong></p><p><strong>传输控制协议</strong> (Transmission Control Protocol)。<strong>TCP 协议是面向连接的通信协议</strong>，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过 “三次握手”。</p><p><strong>三次握手</strong>：TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p><ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</li></ul><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP 协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><p>&lt;img src=&quot;file://D:\Java%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91\02-Java%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6\day11_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\img\4_tcp.jpg?lastModify=1624626182&quot; alt=&quot;img&quot; /&gt;</p></li></ul><h3 id="14网络编程三要素"><a class="anchor" href="#14网络编程三要素">#</a> 1.4 网络编程三要素</h3><ol><li><p><strong>协议</strong></p><ul><li><strong>协议</strong>：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul></li><li><p><strong>IP 地址</strong></p><ul><li><p><strong>IP 地址</strong>：指互联网协议地址（Internet Protocol Address），俗称 IP。IP 地址用来给一个网络中的计算机设备做唯一的编号。假如我们把 “个人电脑” 比作 “一台电话” 的话，那么 “IP 地址” 就相当于 “电话号码”。</p></li><li><p><strong>IP 地址的分类</strong></p><ul><li><strong>IPv4</strong>：是一个 32 位的二进制数，通常被分为 4 个字节，表示成 <code>a.b.c.d</code> 的形式，例如 <code>192.168.65.100</code> 。其中 a、b、c、d 都是 0~255 之间的十进制整数，那么最多可以表示 42 亿个。</li><li><strong>IPv6</strong>：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，表示成 <code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code> ，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</li></ul></li><li><p><strong>常用命令</strong></p><ul><li><p>查看本机 IP 地址，在控制台输入：</p><p><code>ipconfig</code></p></li><li><p>检查网路是否连通，在控制台输入：</p><p><code>ping 空格 IP地址</code></p></li><li><p>特殊的 IP 地址：</p><p>本机 IP 地址： <code>127.0.0.1</code> , <code>localhost</code></p></li></ul></li></ul></li><li><p><strong>端口号</strong></p><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong> IP 地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号</strong>：** 用两个字节表示的整数，它的取值范围是 0<sub>65535**。其中，0</sub>1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用 <code>协议</code> + <code>IP地址</code> + <code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p></li></ol><h2 id="2tcp通信程序"><a class="anchor" href="#2tcp通信程序">#</a> 2.TCP 通信程序</h2><h3 id="21概述"><a class="anchor" href="#21概述">#</a> 2.1 概述</h3><blockquote><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为<strong>客户端</strong>（Client）与<strong>服务端</strong>（Server）。</p></blockquote><ul><li><p><strong>两端通信时步骤：</strong></p><ol><li><strong>服务端程序，需要事先启动</strong>，等待客户端的连接。</li><li><strong>客户端主动连接服务器端</strong>，连接成功才能通信。服务端不可以主动连接客户端。</li></ol></li><li><p><strong>在 Java 中，提供了两个类用于实现 TCP 通信程序：</strong></p><ol><li>客户端： <code>java.net.Socket</code> 类表示。创建 <code>Socket</code> 对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端： <code>java.net.ServerSocket</code> 类表示。创建 <code>ServerSocket</code> 对象，相当于开启一个服务，并等待客户端的连接。</li></ol></li></ul><h3 id="22socket类"><a class="anchor" href="#22socket类">#</a> 2.2Socket 类</h3><blockquote><p><code>Socket</code> 类：该类实现<strong>客户端套接字</strong>，套接字指的是两台设备之间通讯的端点。</p></blockquote><ul><li><p><strong>构造方法</strong></p><ul><li><p><code>public Socket(String host, int port)</code> : 创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的 host 是 null ，则相当于指定地址为回送地址。</p><blockquote><p>小贴士：回送地址 (127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li><li><p>构造举例</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p></p></li></ul></li><li><p><strong>成员方法</strong></p><ul><li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。<ul><li>如果此 Scoket 具有相关联的通道，则生成的 InputStream 的所有操作也关联该通道。</li><li>关闭生成的 InputStream 也将关闭相关的 Socket。</li></ul></li><li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。<ul><li>如果此 Scoket 具有相关联的通道，则生成的 OutputStream 的所有操作也关联该通道。</li><li>关闭生成的 OutputStream 也将关闭相关的 Socket。</li></ul></li><li><code>public void close()</code> ：关闭此套接字。<ul><li>一旦一个 socket 被关闭，它不可再使用。</li><li>关闭此 socket 也将关闭相关的 InputStream 和 OutputStream 。</li></ul></li><li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。<ul><li>任何先前写出的数据将被发送，随后终止输出流。</li></ul></li></ul></li></ul><h3 id="23serversocket类"><a class="anchor" href="#23serversocket类">#</a> 2.3ServerSocket 类</h3><blockquote><p><code>ServerSocket</code> 类：这个类实现了<strong>服务器套接字</strong>，该对象等待通过网络的请求。</p></blockquote><ul><li><p><strong>构造方法</strong></p><ul><li><p><code>public ServerSocket(int port)</code> ：使用该构造方法在创建 ServerSocket 对象时，就可以将其绑定到一个指定的端口号上，参数 port 就是端口号。</p></li><li><p>构造举例，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p></p></li></ul></li><li><p><strong>成员方法</strong></p><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的 Socket 对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。</li></ul></li></ul><h3 id="24简单的tcp网络程序"><a class="anchor" href="#24简单的tcp网络程序">#</a> 2.4 简单的 TCP 网络程序</h3><ul><li><p><strong>TCP 通信分析图解</strong></p><ol><li><p>【服务端】启动，创建 ServerSocket 对象，等待连接。</p></li><li><p>【客户端】启动，创建 Socket 对象，请求连接。</p></li><li><p>【服务端】接收连接，调用 accept 方法，并返回一个 Socket 对象。</p></li><li><p>【客户端】Socket 对象，获取 OutputStream，向服务端写出数据。</p></li><li><p>【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据。</p><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote></li><li><p>【服务端】Socket 对象，获取 OutputStream，向客户端回写数据。</p></li><li><p>【客户端】Scoket 对象，获取 InputStream，解析回写数据。</p></li><li><p>【客户端】释放资源，断开连接。</p></li></ol></li><li><p><strong>代码实现</strong></p><p><strong>服务端实现：</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动，等待连接...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过 socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">        <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b);</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.通过 socket 获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">        <span class="comment">//6.回写数据</span></span><br><span class="line">        out.write(<span class="string">&quot;客户端我收到了！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//7.关闭资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>客户端实现：</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客服端发送数据&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建 Socket(ip,port),确定连接到哪里</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//2.通过Scoket 获取输出流对象 </span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        <span class="comment">//3.写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;你好吗？tcp,我来了&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//4.通过Scoket 获取输入流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">        <span class="comment">// 5. 读取数据</span></span><br><span class="line">        <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=in.read(b);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">// 6. 关闭资源</span></span><br><span class="line">        in.close();</span><br><span class="line">        os.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><h2 id="3综合案例"><a class="anchor" href="#3综合案例">#</a> 3. 综合案例</h2><h3 id="31文件上传案例"><a class="anchor" href="#31文件上传案例">#</a> 3.1 文件上传案例</h3><ul><li><p><strong>文件上传分析图解</strong></p><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol></li><li><p><strong>信息回写分析图解</strong></p><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol></li><li><p><strong>文件上传优化分析</strong></p><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="literal">true</span>）&#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol></li><li><p><strong>代码实现</strong></p><p><strong>客户端实现</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建输出流，写到服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(client.getOutputStream());</span><br><span class="line">        <span class="comment">//创建输入流，读取本地文件</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xpp.jpg&quot;</span>));</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//写出数据</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len=bis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭输出流，通知服务端，写出数据完毕</span></span><br><span class="line">        client.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕！&quot;</span>);</span><br><span class="line">		<span class="comment">//解析回写</span></span><br><span class="line">        BufferedInputStream bis1=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(client.getInputStream());</span><br><span class="line">        <span class="keyword">while</span>((len=bis1.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bis1.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>服务端实现</strong></p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器---启动----&quot;</span>);</span><br><span class="line">		<span class="comment">//创建服务端ss</span></span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//循环接收，建立连接</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(server.getInputStream());</span><br><span class="line">                    <span class="comment">//创建输出流，保存到本地</span></span><br><span class="line">                    BufferedOutputStream  bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">                    <span class="comment">//读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1014</span>*<span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span>((len=bis.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        bos.write(b,<span class="number">0</span>,len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4.信息回写</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;back.......&quot;</span>);</span><br><span class="line">                    BufferedOutputStream bos1=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(server.getOutputStream());</span><br><span class="line">                    bos1.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">					<span class="comment">//关闭资源</span></span><br><span class="line">                    bos1.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    bos.close();</span><br><span class="line">                    server.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传保存！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ul><div class="tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="ic i-tag"></i> 学习</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-05 21:02:35" itemprop="dateModified" datetime="2024-10-05T21:02:35+08:00">2024-10-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="REMU 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="REMU 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="REMU 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>REMU <i class="ic i-at"><em>@</em></i>REM</li><li class="link"><strong>本文链接：</strong> <a href="https://loveremu.github.io/2023/06/13/JAVA(%E6%91%98%E6%8A%84)/" title="JAVA(摘抄)">https://loveremu.github.io/2023/06/13/JAVA(摘抄)/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/13/JAVA/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;4-min.png" title="JAVA"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 语言基础</span><h3>JAVA</h3></a></div><div class="item right"><a href="/2023/06/29/%E5%86%B0%E6%B5%B7%E6%88%98%E8%AE%B0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;LOVEREMU.github.io&#x2F;images&#x2F;10-min.png" title="冰海战记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> ACGN disscuss</span><h3>冰海战记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#collectioniterator"><span class="toc-number">1.</span> <span class="toc-text">Collection+Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80collection%E9%9B%86%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">一・Collection 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 集合概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 集合框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13collection%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3Collection 常用功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二. Iterator 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21iterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1Iterator 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%A2%9E%E5%8A%A0for"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 增加 for</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-file%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">第一章 File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">获取功能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">判断功能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">创建删除功能的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.4.</span> <span class="toc-text">绝对路径和相对路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%9B%AE%E5%BD%95%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 目录的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%80%92%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">第二章 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%80%92%E5%BD%92%E7%B4%AF%E5%8A%A0%E6%B1%82%E5%92%8C"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 递归累加求和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%971-~-n%E7%9A%84%E5%92%8C"><span class="toc-number">3.2.1.</span> <span class="toc-text">计算 1 ~ n 的和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 递归求阶乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 递归打印多级目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">第三章 综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 文件搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 文件过滤器优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-lambda%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 Lambda 优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">Java---Junit 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">1. 测试分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2junit%E4%BD%BF%E7%94%A8%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.Junit 使用：白盒测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-stream%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">Java---Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%BC%95%E8%A8%80"><span class="toc-number">6.1.</span> <span class="toc-text">1. 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0"><span class="toc-number">6.2.</span> <span class="toc-text">2. 流式思想概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">6.3.</span> <span class="toc-text">3. 获取流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E6%A0%B9%E6%8D%AEcollection%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1 根据 Collection 获取流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E6%A0%B9%E6%8D%AEmap%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2 根据 Map 获取流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E6%A0%B9%E6%8D%AE%E6%95%B0%E7%BB%84%E8%8E%B7%E5%8F%96%E6%B5%81"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3 根据数组获取流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">4. 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E9%80%90%E4%B8%80%E5%A4%84%E7%90%86foreach"><span class="toc-number">6.4.1.</span> <span class="toc-text">4.1 逐一处理：forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E8%BF%87%E6%BB%A4filter"><span class="toc-number">6.4.2.</span> <span class="toc-text">4.2 过滤：filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E6%98%A0%E5%B0%84map"><span class="toc-number">6.4.3.</span> <span class="toc-text">4.3 映射：map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E7%BB%9F%E8%AE%A1%E4%B8%AA%E6%95%B0count"><span class="toc-number">6.4.4.</span> <span class="toc-text">4.4 统计个数：count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E5%8F%96%E7%94%A8%E5%89%8D%E5%87%A0%E4%B8%AAlimit"><span class="toc-number">6.4.5.</span> <span class="toc-text">4.5 取用前几个：limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E8%B7%B3%E8%BF%87%E5%89%8D%E5%87%A0%E4%B8%AAskip"><span class="toc-number">6.4.6.</span> <span class="toc-text">4.6 跳过前几个：skip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E7%BB%84%E5%90%88concat"><span class="toc-number">6.4.7.</span> <span class="toc-text">4.7 组合：concat</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8api"><span class="toc-number">7.</span> <span class="toc-text">常用 API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1object%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">1.Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12tostring%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2toString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13equals%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">1.3equals 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14objects%E7%B1%BB"><span class="toc-number">7.1.4.</span> <span class="toc-text">1.4Objects 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">2. 日期时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21date%E7%B1%BB"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1Date 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22dateformat%E7%B1%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2DateFormat 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23calender%E7%B1%BB"><span class="toc-number">7.2.3.</span> <span class="toc-text">2.3Calender 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3system%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">3.System 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31currenttimemillis%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1currentTimeMillis 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32arraycopy%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.2.</span> <span class="toc-text">3.2arraycopy 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4stringbuilder%E7%B1%BB"><span class="toc-number">7.4.</span> <span class="toc-text">4.StringBuilder 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 字符串拼接问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42stringbuilder%E6%A6%82%E8%BF%B0"><span class="toc-number">7.4.2.</span> <span class="toc-text">4.2StringBuilder 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.3.</span> <span class="toc-text">4.3 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.4.</span> <span class="toc-text">4.4 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">7.5.</span> <span class="toc-text">5. 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E6%A6%82%E8%BF%B0"><span class="toc-number">7.5.1.</span> <span class="toc-text">5.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">7.5.2.</span> <span class="toc-text">5.2 装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-number">7.5.3.</span> <span class="toc-text">5.3 自动装箱与自动拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.5.4.</span> <span class="toc-text">5.4 基本类型与字符串之间的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6math%E7%B1%BB"><span class="toc-number">7.6.</span> <span class="toc-text">6.Math 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7arrays%E7%B1%BB"><span class="toc-number">7.7.</span> <span class="toc-text">7.Arrays 类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E5%8F%8D%E5%B0%84"><span class="toc-number">8.</span> <span class="toc-text">Java--- 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1. 反射概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">2. 获取 Class 对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3class%E5%AF%B9%E8%B1%A1%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.</span> <span class="toc-text">3.Class 对象功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 获取功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84%E9%9A%8F%E7%AC%94"><span class="toc-number">9.</span> <span class="toc-text">Java 反射随笔✌</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80"><span class="toc-number">9.1.</span> <span class="toc-text">1. 反射基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11class%E7%B1%BB"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.1Class 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">9.1.2.</span> <span class="toc-text">1.2 类加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">2. 反射的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21class%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1Class 对象的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22constructor%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2Constructor 类及其用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23field%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95"><span class="toc-number">9.2.3.</span> <span class="toc-text">2.3Field 类及其用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24method%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95"><span class="toc-number">9.2.4.</span> <span class="toc-text">2.4Method 类及其用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">Java--- 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">1. 泛型概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2. 泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA%E7%B1%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">2.1 用泛型表示类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.2 用泛型表示接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.3.</span> <span class="toc-text">2.3 用泛型表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">10.2.4.</span> <span class="toc-text">2.4 泛型通配符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.</span> <span class="toc-text">Java--- 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.</span> <span class="toc-text">1. 自定义函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E6%A6%82%E8%BF%B0-2"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.2 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13functionalinterface%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.3@FunctionalInterface 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.4.</span> <span class="toc-text">1.4 自定义函数式接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">2. 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21lambda%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1Lambda 的延迟执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E4%BD%BF%E7%94%A8lambda%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2 使用 Lambda 作为参数和返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.</span> <span class="toc-text">3. 常用函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31supplier%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1Supplier 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32consumer%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2Consumer 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33predicate%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.3Predicate 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34function%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.4.</span> <span class="toc-text">3.4Function 接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">12.</span> <span class="toc-text">缓冲流 + 转换流 + 序列化流 + 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">12.1.</span> <span class="toc-text">1. 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E6%A6%82%E8%BF%B0-3"><span class="toc-number">12.1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">12.1.2.</span> <span class="toc-text">1.2 字节缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">12.1.3.</span> <span class="toc-text">1.3 字符缓冲流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E8%BD%AC%E5%8C%96%E6%B5%81"><span class="toc-number">12.2.</span> <span class="toc-text">2. 转化流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">12.2.1.</span> <span class="toc-text">2.1 字符编码和字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E7%BC%96%E7%A0%81%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.2.</span> <span class="toc-text">2.2 编码引出的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23inputstreamreader%E7%B1%BB"><span class="toc-number">12.2.3.</span> <span class="toc-text">2.3InputStreamReader 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24outputstreamwriter%E7%B1%BB"><span class="toc-number">12.2.4.</span> <span class="toc-text">2.4OutputStreamWriter 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.3.</span> <span class="toc-text">3. 序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E6%A6%82%E8%BF%B0"><span class="toc-number">12.3.1.</span> <span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81-objectoutputstream%E7%B1%BB"><span class="toc-number">12.3.2.</span> <span class="toc-text">3.2 序列化流 - ObjectOutputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81-objectinputstream%E7%B1%BB"><span class="toc-number">12.3.3.</span> <span class="toc-text">3.3 反序列化流 - ObjectInputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E7%BB%83%E4%B9%A0%E5%BA%8F%E5%88%97%E5%8C%96%E9%9B%86%E5%90%88"><span class="toc-number">12.3.4.</span> <span class="toc-text">3.4 练习：序列化集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">12.4.</span> <span class="toc-text">4. 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%A6%82%E8%BF%B0"><span class="toc-number">12.4.1.</span> <span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42printstream%E7%B1%BB"><span class="toc-number">12.4.2.</span> <span class="toc-text">4.2PrintStream 类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">Java--- 面向对象概念总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%BB%A7%E6%89%BF"><span class="toc-number">13.1.</span> <span class="toc-text">1. 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">13.1.1.</span> <span class="toc-text">1.1 继承的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E7%BB%A7%E6%89%BF%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">13.1.2.</span> <span class="toc-text">1.2 继承关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">13.1.3.</span> <span class="toc-text">1.3 构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99override%E4%B8%8E%E9%87%8D%E8%BD%BDoverload"><span class="toc-number">13.2.</span> <span class="toc-text">2. 重写 (Override) 与重载 (Overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E9%87%8D%E5%86%99"><span class="toc-number">13.2.1.</span> <span class="toc-text">2.1 重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E9%87%8D%E8%BD%BD"><span class="toc-number">13.2.2.</span> <span class="toc-text">2.2 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.2.3.</span> <span class="toc-text">2.3 重写与重载的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E6%80%BB%E7%BB%93"><span class="toc-number">13.2.4.</span> <span class="toc-text">2.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%A4%9A%E6%80%81"><span class="toc-number">13.3.</span> <span class="toc-text">3. 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.3.1.</span> <span class="toc-text">4. 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">13.3.2.</span> <span class="toc-text">4.1 抽象类概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.3.</span> <span class="toc-text">4.2 抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">13.3.4.</span> <span class="toc-text">4.3 抽象类总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%B0%81%E8%A3%85"><span class="toc-number">13.4.</span> <span class="toc-text">5. 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.5.</span> <span class="toc-text">6. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">13.5.1.</span> <span class="toc-text">6.1 接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9B%B8%E4%BC%BC%E7%82%B9"><span class="toc-number">13.5.2.</span> <span class="toc-text">6.2 接口与类相似点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.5.3.</span> <span class="toc-text">6.3 接口与类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="toc-number">13.5.4.</span> <span class="toc-text">6.4 接口特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.5.5.</span> <span class="toc-text">6.5 接口与抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.5.6.</span> <span class="toc-text">6.6 接口的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81and%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">14.</span> <span class="toc-text">字节流 and 字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80io%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">一.IO 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1io%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">14.1.1.</span> <span class="toc-text">1.IO 的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%A1%B6%E7%BA%A7%E7%88%B6%E7%B1%BB%E4%BB%AC"><span class="toc-number">14.1.2.</span> <span class="toc-text">2. 顶级父类们</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">14.2.</span> <span class="toc-text">二。字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81outputstream"><span class="toc-number">14.2.1.</span> <span class="toc-text">1. 字节输出流 OutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2fileoutputstream%E7%B1%BB"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.FileOutputStream 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">14.2.2.1.</span> <span class="toc-text">(1) 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%86%99%E5%87%BA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.2.2.</span> <span class="toc-text">(2) 写出字节数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%95%B0%E6%8D%AE%E8%BF%BD%E5%8A%A0%E7%BB%AD%E5%86%99"><span class="toc-number">14.2.2.3.</span> <span class="toc-text">(3) 数据追加续写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81inputstream"><span class="toc-number">14.2.3.</span> <span class="toc-text">3. 字节输入流 [InputStream]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-fileinputstream%E7%B1%BB"><span class="toc-number">14.2.4.</span> <span class="toc-text">4. FileInputStream 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">14.2.4.1.</span> <span class="toc-text">(1) 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.4.2.</span> <span class="toc-text">(2) 读取字节数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%AD%97%E8%8A%82%E6%B5%81%E7%BB%83%E4%B9%A0%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6"><span class="toc-number">14.2.5.</span> <span class="toc-text">5. 字节流练习：图片复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">14.3.</span> <span class="toc-text">三。字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81reader"><span class="toc-number">14.3.1.</span> <span class="toc-text">1. 字符输入流 [Reader]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2filereader%E7%B1%BB"><span class="toc-number">14.3.2.</span> <span class="toc-text">2.FileReader 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-3"><span class="toc-number">14.3.2.1.</span> <span class="toc-text">(1) 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">14.3.2.2.</span> <span class="toc-text">(2) 读取字符数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81writer"><span class="toc-number">14.3.3.</span> <span class="toc-text">3. 字符输出流 [Writer]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4filewriter%E7%B1%BB"><span class="toc-number">14.3.4.</span> <span class="toc-text">4.FileWriter 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-4"><span class="toc-number">14.3.4.1.</span> <span class="toc-text">(1) 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%9F%BA%E6%9C%AC%E5%86%99%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">14.3.4.2.</span> <span class="toc-text">(2) 基本写出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%85%B3%E9%97%AD%E5%92%8C%E5%88%B7%E6%96%B0"><span class="toc-number">14.3.4.3.</span> <span class="toc-text">(3) 关闭和刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%86%99%E5%87%BA%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE"><span class="toc-number">14.3.4.4.</span> <span class="toc-text">(4) 写出其它数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9Bio%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">14.4.</span> <span class="toc-text">四.IO 异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1jdk7%E5%89%8D%E5%A4%84%E7%90%86"><span class="toc-number">14.4.1.</span> <span class="toc-text">1.JDK7 前处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2jdk7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">14.4.2.</span> <span class="toc-text">2.JDK7 的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3jdk9%E7%9A%84%E6%94%B9%E8%BF%9B%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9"><span class="toc-number">14.4.3.</span> <span class="toc-text">3.JDK9 的改进 (扩展知识点了解内容)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%B1%9E%E6%80%A7%E9%9B%86"><span class="toc-number">14.5.</span> <span class="toc-text">五。属性集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-5"><span class="toc-number">14.5.1.</span> <span class="toc-text">1. 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.5.2.</span> <span class="toc-text">2. 基本的存储方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%B8%8E%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.5.3.</span> <span class="toc-text">3. 与流相关的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80list"><span class="toc-number">15.</span> <span class="toc-text">一.List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11list%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">15.1.</span> <span class="toc-text">1.1List 接口概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12list%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">1.2List 接口中常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13arraylist%E9%9B%86%E5%90%88"><span class="toc-number">15.3.</span> <span class="toc-text">1.3ArrayList 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14linkedlist%E9%9B%86%E5%90%88"><span class="toc-number">15.4.</span> <span class="toc-text">1.4LinkedList 集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8Cset"><span class="toc-number">16.</span> <span class="toc-text">二.Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21set%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text">2.1Set 接口概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22hashset%E9%9B%86%E5%90%88"><span class="toc-number">16.2.</span> <span class="toc-text">2.2HashSet 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23hashset%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">16.3.</span> <span class="toc-text">2.3HashSet 集合存储数据的结构（哈希表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24hashset%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0"><span class="toc-number">16.4.</span> <span class="toc-text">2.4HashSet 存储自定义类型元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25linkedhashset"><span class="toc-number">16.5.</span> <span class="toc-text">2.5LinkedHashSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89collections"><span class="toc-number">17.</span> <span class="toc-text">三.Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">17.1.</span> <span class="toc-text">3.1 常用功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32comparator%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">17.2.</span> <span class="toc-text">3.2Comparator 比较器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E7%AE%80%E8%BF%B0comparable%E5%92%8Ccomparator%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.3.</span> <span class="toc-text">3.3 简述 Comparable 和 Comparator 两个接口的区别。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map"><span class="toc-number">18.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80map%E9%9B%86%E5%90%88"><span class="toc-number">18.1.</span> <span class="toc-text">一.Map 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E6%A6%82%E8%BF%B0-4"><span class="toc-number">18.1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12map%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB"><span class="toc-number">18.1.2.</span> <span class="toc-text">1.2Map 常用子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.1.3.</span> <span class="toc-text">1.3Map 接口中的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14hashmap%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E9%94%AE%E5%80%BC"><span class="toc-number">18.1.4.</span> <span class="toc-text">1.4HashMap 存储自定义类型键值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15linkedhashmap"><span class="toc-number">18.1.5.</span> <span class="toc-text">1.5LinkedHashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java-%E6%B3%A8%E8%A7%A3"><span class="toc-number">19.</span> <span class="toc-text">Java--- 注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-number">20.1.</span> <span class="toc-text">1. 网络编程入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">20.1.1.</span> <span class="toc-text">1.1 软件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">20.1.2.</span> <span class="toc-text">1.2 网络通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E5%8D%8F%E8%AE%AE%E5%88%86%E7%B1%BB"><span class="toc-number">20.1.3.</span> <span class="toc-text">1.3 协议分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">20.1.4.</span> <span class="toc-text">1.4 网络编程三要素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2tcp%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">20.2.</span> <span class="toc-text">2.TCP 通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E6%A6%82%E8%BF%B0"><span class="toc-number">20.2.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22socket%E7%B1%BB"><span class="toc-number">20.2.2.</span> <span class="toc-text">2.2Socket 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23serversocket%E7%B1%BB"><span class="toc-number">20.2.3.</span> <span class="toc-text">2.3ServerSocket 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E7%AE%80%E5%8D%95%E7%9A%84tcp%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F"><span class="toc-number">20.2.4.</span> <span class="toc-text">2.4 简单的 TCP 网络程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">20.3.</span> <span class="toc-text">3. 综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B"><span class="toc-number">20.3.1.</span> <span class="toc-text">3.1 文件上传案例</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/05/28/C++STL%E5%9F%BA%E6%93%8D/" rel="bookmark" title="STL基操">STL基操</a></li><li><a href="/2023/05/28/markdown%E5%9F%BA%E6%93%8D/" rel="bookmark" title="markdown基操">markdown基操</a></li><li><a href="/2023/05/29/python/" rel="bookmark" title="python基操">python基操</a></li><li><a href="/2023/06/05/C++%E4%B8%ADsscanf,sprintf/" rel="bookmark" title="C++中字符之间的转换">C++中字符之间的转换</a></li><li class="active"><a href="/2023/06/13/JAVA(%E6%91%98%E6%8A%84)/" rel="bookmark" title="JAVA(摘抄)">JAVA(摘抄)</a></li><li><a href="/2023/06/13/JAVA/" rel="bookmark" title="JAVA">JAVA</a></li><li><a href="/2023/07/28/JAVA-PLUS/" rel="bookmark" title="JAVA-PLUS">JAVA-PLUS</a></li><li><a href="/2024/02/05/MySQL(%E6%91%98%E6%8A%84)/" rel="bookmark" title="MySQL(摘抄)">MySQL(摘抄)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="REMU" data-src="/images/avatar.jpg"><p class="name" itemprop="name">REMU</p><div class="description" itemprop="description">LOVEREMU blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/13/JAVA/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/29/%E5%86%B0%E6%B5%B7%E6%88%98%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/%E5%89%8D%E7%AB%AF(%E6%91%98%E6%8A%84)/" title="前端(摘抄)">前端(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="分类于 语言基础">语言基础</a></div><span><a href="/2023/06/13/JAVA/" title="JAVA">JAVA</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="分类于 工程基础">工程基础</a></div><span><a href="/2024/04/28/SSM(%E6%91%98%E6%8A%84)/" title="SSM(摘抄)">SSM(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E6%91%98%E6%8A%84)/" title="计算机网络(摘抄)">计算机网络(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ACGN-disscuss/" title="分类于 ACGN disscuss">ACGN disscuss</a></div><span><a href="/2023/06/01/EVA/" title="EVA">EVA</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%91%98%E6%8A%84)/" title="操作系统(摘抄)">操作系统(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%91%98%E6%8A%84%EF%BC%89/" title="数据结构(摘抄)">数据结构(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/408/" title="分类于 408">408</a></div><span><a href="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86(%E6%91%98%E6%8A%84)/" title="计算机组成原理(摘抄)">计算机组成原理(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="分类于 语言基础">语言基础</a></div><span><a href="/2023/06/13/JAVA(%E6%91%98%E6%8A%84)/" title="JAVA(摘抄)">JAVA(摘抄)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 算法与数据结构">算法与数据结构</a></div><span><a href="/2023/07/21/%E6%95%B0%E8%AE%BA/" title="数学知识">数学知识</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">REMU @ REMU's blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/06/13/JAVA(摘抄)/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->